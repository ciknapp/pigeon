--------------------------------------------------------
--  File created - Tuesday-May-03-2022   
--------------------------------------------------------
DROP SEQUENCE "CS414_TEAM2"."FILE_ID";
DROP SEQUENCE "CS414_TEAM2"."GROUP_ID_SEQ";
DROP SEQUENCE "CS414_TEAM2"."SEQ_NOTIF_ID";
DROP SEQUENCE "CS414_TEAM2"."SEQ_USER_ICON_ID";
DROP SEQUENCE "CS414_TEAM2"."TEST_RESULT_SEQ";
DROP SEQUENCE "CS414_TEAM2"."TEXT_ID";
DROP SEQUENCE "CS414_TEAM2"."USER_ID";
DROP SEQUENCE "CS414_TEAM2"."FILE_ID";
DROP SEQUENCE "CS414_TEAM2"."TEXT_ID";
DROP SEQUENCE "CS414_TEAM2"."GROUP_ID_SEQ";
DROP SEQUENCE "CS414_TEAM2"."SEQ_NOTIF_ID";
DROP SEQUENCE "CS414_TEAM2"."USER_ID";
DROP SEQUENCE "CS414_TEAM2"."TEST_RESULT_SEQ";
DROP TABLE "CS414_TEAM2"."FILE_EXTENSIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."FLAG_RELATIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."INVITATION_TABLE" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_FILE" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_GROUP" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_TEXT" cascade constraints;
DROP TABLE "CS414_TEAM2"."NOTIFICATIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."TEST_RESULTS" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_ICONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_INFORMATION" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_RELATIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_TEXT" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_INFORMATION" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_GROUP" cascade constraints;
DROP TABLE "CS414_TEAM2"."MESSAGE_FILE" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_ICONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."FILE_EXTENSIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."FLAG_RELATIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."INVITATION_TABLE" cascade constraints;
DROP TABLE "CS414_TEAM2"."NOTIFICATIONS" cascade constraints;
DROP TABLE "CS414_TEAM2"."TEST_RESULTS" cascade constraints;
DROP TABLE "CS414_TEAM2"."USER_RELATIONS" cascade constraints;
DROP PACKAGE "CS414_TEAM2"."ADMIN";
DROP PACKAGE "CS414_TEAM2"."DEFINITIONS";
DROP PACKAGE "CS414_TEAM2"."DEV_TEMPLATES";
DROP PACKAGE "CS414_TEAM2"."MESSAGING";
DROP PACKAGE "CS414_TEAM2"."NESTS";
DROP PACKAGE "CS414_TEAM2"."NOTIFICATION_API";
DROP PACKAGE "CS414_TEAM2"."SEARCHING";
DROP PACKAGE "CS414_TEAM2"."SECURITY";
DROP PACKAGE "CS414_TEAM2"."STATISTICS";
DROP PACKAGE "CS414_TEAM2"."TESTING";
DROP PACKAGE "CS414_TEAM2"."USER_SETTINGS";
DROP PACKAGE "CS414_TEAM2"."DEFINITIONS";
DROP PACKAGE "CS414_TEAM2"."ADMIN";
DROP PACKAGE "CS414_TEAM2"."NOTIFICATION_API";
DROP PACKAGE "CS414_TEAM2"."SECURITY";
DROP PACKAGE "CS414_TEAM2"."USER_SETTINGS";
DROP PACKAGE "CS414_TEAM2"."MESSAGING";
DROP PACKAGE "CS414_TEAM2"."NESTS";
DROP PACKAGE "CS414_TEAM2"."SEARCHING";
DROP PACKAGE "CS414_TEAM2"."STATISTICS";
DROP PACKAGE "CS414_TEAM2"."TESTING";
DROP PACKAGE BODY "CS414_TEAM2"."ADMIN";
DROP PACKAGE BODY "CS414_TEAM2"."MESSAGING";
DROP PACKAGE BODY "CS414_TEAM2"."NESTS";
DROP PACKAGE BODY "CS414_TEAM2"."NOTIFICATION_API";
DROP PACKAGE BODY "CS414_TEAM2"."SEARCHING";
DROP PACKAGE BODY "CS414_TEAM2"."SECURITY";
DROP PACKAGE BODY "CS414_TEAM2"."STATISTICS";
DROP PACKAGE BODY "CS414_TEAM2"."TESTING";
DROP PACKAGE BODY "CS414_TEAM2"."USER_SETTINGS";
DROP SYNONYM "PUBLIC"."DBMS_CRYPTO";
DROP SYNONYM "PUBLIC"."DBMS_LOB";
DROP SYNONYM "PUBLIC"."DBMS_RANDOM";
DROP SYNONYM "PUBLIC"."DUAL";
DROP SYNONYM "PUBLIC"."UTL_I18N";
DROP SYNONYM "PUBLIC"."UTL_RAW";
--------------------------------------------------------
--  DDL for Sequence FILE_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."FILE_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 157 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence GROUP_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."GROUP_ID_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 342 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SEQ_NOTIF_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."SEQ_NOTIF_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 728 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SEQ_USER_ICON_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."SEQ_USER_ICON_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence TEST_RESULT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."TEST_RESULT_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 838 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence TEXT_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."TEXT_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8308 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence USER_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."USER_ID"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 510 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence FILE_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."FILE_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 157 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence TEXT_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."TEXT_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8308 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence GROUP_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."GROUP_ID_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 342 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SEQ_NOTIF_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."SEQ_NOTIF_ID"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 728 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence USER_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."USER_ID"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 510 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence TEST_RESULT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CS414_TEAM2"."TEST_RESULT_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 838 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Table FILE_EXTENSIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."FILE_EXTENSIONS" 
   (	"EXTENSION" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FLAG_RELATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."FLAG_RELATIONS" 
   (	"USER_ID" NUMBER(10,0), 
	"TEXT_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table INVITATION_TABLE
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."INVITATION_TABLE" 
   (	"USER_ID" NUMBER(10,0) DEFAULT (NULL), 
	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"IS_INVITED" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"LOCAL_ROLE" NUMBER(2,0) DEFAULT 3, 
	"LAST_CHECKED" TIMESTAMP (6), 
	"IS_ACTIVITY_NEW" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"INVITE_STATUS" VARCHAR2(1 BYTE) DEFAULT 'P', 
	"IS_MUTED" VARCHAR2(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."USER_ID" IS 'User''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."IS_INVITED" IS 'Checks if user is invited to the message group';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."LOCAL_ROLE" IS '0 = system admin; 1 = nest creator; 2 = local admin; 3 = default; 4+ customs;';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."LAST_CHECKED" IS 'The last time the user checked this nest';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."IS_ACTIVITY_NEW" IS 'Checks if there is a new activity';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."INVITE_STATUS" IS 'Y = accapted, N = declined, and P = pending.';
--------------------------------------------------------
--  DDL for Table MESSAGE_FILE
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_FILE" 
   (	"FILE_ID" NUMBER(10,0) DEFAULT (NULL), 
	"TEXT_ID" NUMBER(10,0) DEFAULT (NULL), 
	"NAME" VARCHAR2(255 BYTE), 
	"EXTENSION" VARCHAR2(255 BYTE), 
	"ENCRYPTED_FILE" BLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("ENCRYPTED_FILE") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 106496 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_FILE"."FILE_ID" IS 'Message file''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_FILE"."TEXT_ID" IS 'Message text''s unique id (foreign key)';
--------------------------------------------------------
--  DDL for Table MESSAGE_GROUP
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_GROUP" 
   (	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"CRYPTO_KEY" RAW(32) DEFAULT (NULL), 
	"GROUP_NAME" VARCHAR2(50 BYTE), 
	"CREATED_BY" NUMBER(10,0), 
	"LAST_ACTIVITY" TIMESTAMP (6), 
	"VISIBLE" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"PRIVATE" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"LOCKED_BY_ADMIN" VARCHAR2(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."CRYPTO_KEY" IS 'Encrypted message''s crypto key (using Symmetric encryption)';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."GROUP_NAME" IS 'Name given to group by creator
';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."CREATED_BY" IS 'ID of user that created the group';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."LAST_ACTIVITY" IS 'Last activity in the group';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."VISIBLE" IS 'Whether the group is visible or not.';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."PRIVATE" IS 'Whether the group is a private message group';
--------------------------------------------------------
--  DDL for Table MESSAGE_TEXT
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_TEXT" 
   (	"TEXT_ID" NUMBER(10,0) DEFAULT (NULL), 
	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"FILE_ID" NUMBER(10,0), 
	"USER_ID" NUMBER(10,0), 
	"ENCRYPTED_TEXT" RAW(2000), 
	"PERMISSION_ROLE" NUMBER(2,0) DEFAULT 0, 
	"TIME_SENT" DATE, 
	"REPORT_FLAG" NUMBER(10,0) DEFAULT 0, 
	"VISIBLE" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"REVIEWED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."TEXT_ID" IS 'Message text''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."FILE_ID" IS 'Message file''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."USER_ID" IS 'User''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."PERMISSION_ROLE" IS 'Message''s user permission requirement';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."REPORT_FLAG" IS 'Message''s number of reports';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."VISIBLE" IS 'Message visibility';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."REVIEWED" IS 'Message''s review status.';
--------------------------------------------------------
--  DDL for Table NOTIFICATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."NOTIFICATIONS" 
   (	"NOTIF_ID" NUMBER(10,0), 
	"USER_ID" NUMBER(10,0), 
	"NOTIF_BODY" VARCHAR2(1000 BYTE), 
	"TIME_SENT" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEST_RESULTS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."TEST_RESULTS" 
   (	"TEST_ID" NUMBER(10,0), 
	"METHOD_NAME" VARCHAR2(200 BYTE), 
	"RESULT" VARCHAR2(200 BYTE), 
	"TEST_TIMESTAMP" TIMESTAMP (6) DEFAULT SYSTIMESTAMP
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."TEST_ID" IS 'Test''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."METHOD_NAME" IS 'Name of the test that ran';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."RESULT" IS 'Test result';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."TEST_TIMESTAMP" IS 'Timestamp when the test was executed';
--------------------------------------------------------
--  DDL for Table USER_ICONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_ICONS" 
   (	"ICON_ID" NUMBER DEFAULT "CS414_TEAM2"."SEQ_USER_ICON_ID"."NEXTVAL", 
	"IMAGE_URL" VARCHAR2(2000 BYTE), 
	"CITATION" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_ICONS"."IMAGE_URL" IS 'Direct link to image.';
--------------------------------------------------------
--  DDL for Table USER_INFORMATION
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_INFORMATION" 
   (	"USER_ID" NUMBER(10,0), 
	"USER_NAME" VARCHAR2(25 BYTE), 
	"USER_EMAIL" VARCHAR2(254 BYTE), 
	"USER_PASSWORD" VARCHAR2(40 BYTE), 
	"ISLOGIN" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"ATTEMPTNUMBER" NUMBER(1,0) DEFAULT 0, 
	"LASTATTEMPT" TIMESTAMP (6), 
	"LASTLOGIN" TIMESTAMP (6), 
	"CURRENTTOKEN" VARCHAR2(40 BYTE), 
	"LASTONLINE" TIMESTAMP (6), 
	"USER_ROLE" VARCHAR2(100 BYTE) DEFAULT 'user', 
	"USER_PASSCODE" VARCHAR2(40 BYTE), 
	"BANNED" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"NESTS_CREATED" VARCHAR2(1 BYTE) DEFAULT 0, 
	"EMAIL_CONFIRMATION" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"USER_ICON_ID" NUMBER, 
	"REPORT_COUNT" NUMBER(10,0) DEFAULT 0, 
	"LASTCHECKEDNOTIFS" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ID" IS 'user''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_NAME" IS 'user''s name';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_EMAIL" IS 'user''s email';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_PASSWORD" IS 'user''s password: hashed';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."ISLOGIN" IS 'user''s login status (Y = logged in, N = logged out)';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."ATTEMPTNUMBER" IS 'user''s total login attempts';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTATTEMPT" IS 'user''s last login attempt';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTLOGIN" IS 'user''s last login date/time';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."CURRENTTOKEN" IS 'user''s current session token';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTONLINE" IS 'user''s last known activity time (logout usually)';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ROLE" IS 'User''s role';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_PASSCODE" IS 'User''s one time passcode.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."BANNED" IS 'User''s banned status.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."NESTS_CREATED" IS 'The ammount of groups a user has made. Must be less than 6.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."EMAIL_CONFIRMATION" IS 'The value indicating ''Y'' the user has confirmed their email or ''N'' by default that they have not confirmed their email.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ICON_ID" IS 'Matches to an icon in user_icons';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."REPORT_COUNT" IS 'Number of reported messages a user has.';
--------------------------------------------------------
--  DDL for Table USER_RELATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_RELATIONS" 
   (	"USER_ID_A" NUMBER(10,0), 
	"USER_ID_B" NUMBER(10,0), 
	"RELATION" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_RELATIONS"."RELATION" IS 'F = Friend, B = Blocked';
--------------------------------------------------------
--  DDL for Table MESSAGE_TEXT
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_TEXT" 
   (	"TEXT_ID" NUMBER(10,0) DEFAULT (NULL), 
	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"FILE_ID" NUMBER(10,0), 
	"USER_ID" NUMBER(10,0), 
	"ENCRYPTED_TEXT" RAW(2000), 
	"PERMISSION_ROLE" NUMBER(2,0) DEFAULT 0, 
	"TIME_SENT" DATE, 
	"REPORT_FLAG" NUMBER(10,0) DEFAULT 0, 
	"VISIBLE" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"REVIEWED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."TEXT_ID" IS 'Message text''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."FILE_ID" IS 'Message file''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."USER_ID" IS 'User''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."PERMISSION_ROLE" IS 'Message''s user permission requirement';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."REPORT_FLAG" IS 'Message''s number of reports';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."VISIBLE" IS 'Message visibility';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_TEXT"."REVIEWED" IS 'Message''s review status.';
--------------------------------------------------------
--  DDL for Table USER_INFORMATION
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_INFORMATION" 
   (	"USER_ID" NUMBER(10,0), 
	"USER_NAME" VARCHAR2(25 BYTE), 
	"USER_EMAIL" VARCHAR2(254 BYTE), 
	"USER_PASSWORD" VARCHAR2(40 BYTE), 
	"ISLOGIN" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"ATTEMPTNUMBER" NUMBER(1,0) DEFAULT 0, 
	"LASTATTEMPT" TIMESTAMP (6), 
	"LASTLOGIN" TIMESTAMP (6), 
	"CURRENTTOKEN" VARCHAR2(40 BYTE), 
	"LASTONLINE" TIMESTAMP (6), 
	"USER_ROLE" VARCHAR2(100 BYTE) DEFAULT 'user', 
	"USER_PASSCODE" VARCHAR2(40 BYTE), 
	"BANNED" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"NESTS_CREATED" VARCHAR2(1 BYTE) DEFAULT 0, 
	"EMAIL_CONFIRMATION" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"USER_ICON_ID" NUMBER, 
	"REPORT_COUNT" NUMBER(10,0) DEFAULT 0, 
	"LASTCHECKEDNOTIFS" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ID" IS 'user''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_NAME" IS 'user''s name';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_EMAIL" IS 'user''s email';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_PASSWORD" IS 'user''s password: hashed';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."ISLOGIN" IS 'user''s login status (Y = logged in, N = logged out)';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."ATTEMPTNUMBER" IS 'user''s total login attempts';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTATTEMPT" IS 'user''s last login attempt';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTLOGIN" IS 'user''s last login date/time';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."CURRENTTOKEN" IS 'user''s current session token';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."LASTONLINE" IS 'user''s last known activity time (logout usually)';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ROLE" IS 'User''s role';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_PASSCODE" IS 'User''s one time passcode.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."BANNED" IS 'User''s banned status.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."NESTS_CREATED" IS 'The ammount of groups a user has made. Must be less than 6.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."EMAIL_CONFIRMATION" IS 'The value indicating ''Y'' the user has confirmed their email or ''N'' by default that they have not confirmed their email.';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."USER_ICON_ID" IS 'Matches to an icon in user_icons';
   COMMENT ON COLUMN "CS414_TEAM2"."USER_INFORMATION"."REPORT_COUNT" IS 'Number of reported messages a user has.';
--------------------------------------------------------
--  DDL for Table MESSAGE_GROUP
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_GROUP" 
   (	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"CRYPTO_KEY" RAW(32) DEFAULT (NULL), 
	"GROUP_NAME" VARCHAR2(50 BYTE), 
	"CREATED_BY" NUMBER(10,0), 
	"LAST_ACTIVITY" TIMESTAMP (6), 
	"VISIBLE" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"PRIVATE" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"LOCKED_BY_ADMIN" VARCHAR2(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."CRYPTO_KEY" IS 'Encrypted message''s crypto key (using Symmetric encryption)';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."GROUP_NAME" IS 'Name given to group by creator
';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."CREATED_BY" IS 'ID of user that created the group';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."LAST_ACTIVITY" IS 'Last activity in the group';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."VISIBLE" IS 'Whether the group is visible or not.';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_GROUP"."PRIVATE" IS 'Whether the group is a private message group';
--------------------------------------------------------
--  DDL for Table MESSAGE_FILE
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."MESSAGE_FILE" 
   (	"FILE_ID" NUMBER(10,0) DEFAULT (NULL), 
	"TEXT_ID" NUMBER(10,0) DEFAULT (NULL), 
	"NAME" VARCHAR2(255 BYTE), 
	"EXTENSION" VARCHAR2(255 BYTE), 
	"ENCRYPTED_FILE" BLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("ENCRYPTED_FILE") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 106496 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_FILE"."FILE_ID" IS 'Message file''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."MESSAGE_FILE"."TEXT_ID" IS 'Message text''s unique id (foreign key)';
--------------------------------------------------------
--  DDL for Table USER_ICONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_ICONS" 
   (	"ICON_ID" NUMBER DEFAULT "CS414_TEAM2"."SEQ_USER_ICON_ID"."NEXTVAL", 
	"IMAGE_URL" VARCHAR2(2000 BYTE), 
	"CITATION" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_ICONS"."IMAGE_URL" IS 'Direct link to image.';
--------------------------------------------------------
--  DDL for Table FILE_EXTENSIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."FILE_EXTENSIONS" 
   (	"EXTENSION" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FLAG_RELATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."FLAG_RELATIONS" 
   (	"USER_ID" NUMBER(10,0), 
	"TEXT_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table INVITATION_TABLE
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."INVITATION_TABLE" 
   (	"USER_ID" NUMBER(10,0) DEFAULT (NULL), 
	"GROUP_ID" NUMBER(10,0) DEFAULT (NULL), 
	"IS_INVITED" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"LOCAL_ROLE" NUMBER(2,0) DEFAULT 3, 
	"LAST_CHECKED" TIMESTAMP (6), 
	"IS_ACTIVITY_NEW" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"INVITE_STATUS" VARCHAR2(1 BYTE) DEFAULT 'P', 
	"IS_MUTED" VARCHAR2(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."USER_ID" IS 'User''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."GROUP_ID" IS 'Message group''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."IS_INVITED" IS 'Checks if user is invited to the message group';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."LOCAL_ROLE" IS '0 = system admin; 1 = nest creator; 2 = local admin; 3 = default; 4+ customs;';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."LAST_CHECKED" IS 'The last time the user checked this nest';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."IS_ACTIVITY_NEW" IS 'Checks if there is a new activity';
   COMMENT ON COLUMN "CS414_TEAM2"."INVITATION_TABLE"."INVITE_STATUS" IS 'Y = accapted, N = declined, and P = pending.';
--------------------------------------------------------
--  DDL for Table NOTIFICATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."NOTIFICATIONS" 
   (	"NOTIF_ID" NUMBER(10,0), 
	"USER_ID" NUMBER(10,0), 
	"NOTIF_BODY" VARCHAR2(1000 BYTE), 
	"TIME_SENT" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEST_RESULTS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."TEST_RESULTS" 
   (	"TEST_ID" NUMBER(10,0), 
	"METHOD_NAME" VARCHAR2(200 BYTE), 
	"RESULT" VARCHAR2(200 BYTE), 
	"TEST_TIMESTAMP" TIMESTAMP (6) DEFAULT SYSTIMESTAMP
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."TEST_ID" IS 'Test''s unique id';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."METHOD_NAME" IS 'Name of the test that ran';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."RESULT" IS 'Test result';
   COMMENT ON COLUMN "CS414_TEAM2"."TEST_RESULTS"."TEST_TIMESTAMP" IS 'Timestamp when the test was executed';
--------------------------------------------------------
--  DDL for Table USER_RELATIONS
--------------------------------------------------------

  CREATE TABLE "CS414_TEAM2"."USER_RELATIONS" 
   (	"USER_ID_A" NUMBER(10,0), 
	"USER_ID_B" NUMBER(10,0), 
	"RELATION" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "CS414_TEAM2"."USER_RELATIONS"."RELATION" IS 'F = Friend, B = Blocked';
--------------------------------------------------------
--  DDL for Index FILE_EXTENSIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."FILE_EXTENSIONS_PK" ON "CS414_TEAM2"."FILE_EXTENSIONS" ("EXTENSION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FLAG_RELATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."FLAG_RELATIONS_PK" ON "CS414_TEAM2"."FLAG_RELATIONS" ("USER_ID", "TEXT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index NOTIFICATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."NOTIFICATIONS_PK" ON "CS414_TEAM2"."NOTIFICATIONS" ("NOTIF_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_INVITE_ID
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."PK_INVITE_ID" ON "CS414_TEAM2"."INVITATION_TABLE" ("USER_ID", "GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TEXT_ID
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."PK_TEXT_ID" ON "CS414_TEAM2"."MESSAGE_TEXT" ("TEXT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283659
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283659" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283660
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283660" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283661
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283661" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_EMAIL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00286108
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00286108" ON "CS414_TEAM2"."MESSAGE_GROUP" ("GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00286113
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00286113" ON "CS414_TEAM2"."MESSAGE_FILE" ("FILE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index TEST_RESULTS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."TEST_RESULTS_PK" ON "CS414_TEAM2"."TEST_RESULTS" ("TEST_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index USER_ICONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."USER_ICONS_PK" ON "CS414_TEAM2"."USER_ICONS" ("ICON_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index USER_RELATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."USER_RELATIONS_PK" ON "CS414_TEAM2"."USER_RELATIONS" ("USER_ID_A", "USER_ID_B") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FILE_EXTENSIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."FILE_EXTENSIONS_PK" ON "CS414_TEAM2"."FILE_EXTENSIONS" ("EXTENSION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FLAG_RELATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."FLAG_RELATIONS_PK" ON "CS414_TEAM2"."FLAG_RELATIONS" ("USER_ID", "TEXT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_INVITE_ID
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."PK_INVITE_ID" ON "CS414_TEAM2"."INVITATION_TABLE" ("USER_ID", "GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00286113
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00286113" ON "CS414_TEAM2"."MESSAGE_FILE" ("FILE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00286108
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00286108" ON "CS414_TEAM2"."MESSAGE_GROUP" ("GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TEXT_ID
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."PK_TEXT_ID" ON "CS414_TEAM2"."MESSAGE_TEXT" ("TEXT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index NOTIFICATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."NOTIFICATIONS_PK" ON "CS414_TEAM2"."NOTIFICATIONS" ("NOTIF_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index TEST_RESULTS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."TEST_RESULTS_PK" ON "CS414_TEAM2"."TEST_RESULTS" ("TEST_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index USER_ICONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."USER_ICONS_PK" ON "CS414_TEAM2"."USER_ICONS" ("ICON_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283659
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283659" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283660
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283660" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C00283661
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."SYS_C00283661" ON "CS414_TEAM2"."USER_INFORMATION" ("USER_EMAIL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index USER_RELATIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CS414_TEAM2"."USER_RELATIONS_PK" ON "CS414_TEAM2"."USER_RELATIONS" ("USER_ID_A", "USER_ID_B") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Package ADMIN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."ADMIN" AS 

   PROCEDURE IsAdmin (
        p_UserName definitions.t_Username,
        p_UserId   definitions.t_UserID);
   
   FUNCTION GetBannedUsers (
        p_UserName definitions.t_UserName,
        p_UserID   definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetFlaggedMessages (
       p_UserName definitions.t_Username,
       p_UserId   definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedNestMessages (
      p_UserName definitions.t_Username,
      p_GroupId definitions.t_GroupId,
      p_UserId definitions.t_userId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedNestMembers (
      p_UserId definitions.t_userId,
      p_GroupId definitions.t_GroupId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedUserMessages (
     p_UserId definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetAllUsers (
       p_UserName definitions.t_Username,
       p_UserId   definitions.t_UserId)
   RETURN SYS_REFCURSOR;

    PROCEDURE FlagMessage(
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
        
    PROCEDURE UnFlagMessage(
        p_UserName definitions.t_UserName,
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
   
    FUNCTION MessageFlaggedByUser(
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId)
    RETURN VARCHAR2;
    
    PROCEDURE BanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
    PROCEDURE UnBanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
    PROCEDURE ConfirmUserEmail (
        p_UserEmail definitions.t_Email,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
END ADMIN;

/

  GRANT EXECUTE ON "CS414_TEAM2"."ADMIN" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package DEFINITIONS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."DEFINITIONS" AS 
  /* Error code constants */
      /* Any page */
      k_ErrorNoPassNoToken     CONSTANT NUMBER := -20000;
      k_ErrorInvalidToken      CONSTANT NUMBER := -20001;
      k_ErrorUserDoesNotExist  CONSTANT NUMBER := -20002;
      k_ErrorEmailDoesNotExist CONSTANT NUMBER := -20003;
      
      /* Registration */
      k_ErrorUserExistsAlready  CONSTANT NUMBER := -20100;
      k_ErrorEmailExistsAlready CONSTANT NUMBER := -20101;
      k_ErrorInvalidEmail       CONSTANT NUMBER := -20102;
      k_ErrorInvalidUsername    CONSTANT NUMBER := -20103;
      
      /* Login */
      k_ErrorInvalidUserPass   CONSTANT NUMBER := -20200;
      k_ErrorAlreadyLoggedIn   CONSTANT NUMBER := -20201;
      k_ErrorEmailNotConfirmed CONSTANT NUMBER := -20202;
      k_ErrorUserHasBeenBanned CONSTANT NUMBER := -20203;
      
      /* Permissions */
      k_ErrorUserDoesNotHavePermission CONSTANT NUMBER := -20300;
      k_ErrorUserIsNotMessageOwner     CONSTANT NUMBER := -20301;
      
      /* Messages */
      k_ErrorNoNewMessages       CONSTANT NUMBER := -20400;
      k_ErrorWrongFileType       CONSTANT NUMBER := -20401;
      k_ErrorMessageDoesNotExist CONSTANT NUMBER := -20402;
      k_ErrorSpam                CONSTANT NUMBER := -20403;
      k_NestIsLocked             CONSTANT NUMBER := -20404;
      
      /* Pasword Change */
      k_ErrorNoPassNoCode        CONSTANT NUMBER := -20500;
      k_ErrorInvalidUserPasscode CONSTANT NUMBER := -20501;
      
      /* Nests */
      k_ErrorNestDoesNotExist         CONSTANT NUMBER := -20600;
      k_ErrorPrivateNestExistsAlready CONSTANT NUMBER := -20601;
      k_ErrorUserIsNotInAGroup        CONSTANT NUMBER := -20602;
      k_ErrorUsernameIsNull           CONSTANT NUMBER := -20603;
      k_ErrorGroupNameInvalid         CONSTANT NUMBER := -20604;
      k_ErrorTooManyNestsCreated      CONSTANT NUMBER := -20605;
      k_ErrorUserHasNoInvites         CONSTANT NUMBER := -20606;
      k_ErrorAcceptOrRejectInvitation CONSTANT NUMBER := -20607;
      k_ErrorUserInNestAlready        CONSTANT NUMBER := -20608;
      k_ErrorUserNotInGroup           CONSTANT NUMBER := -20809;
      k_ErrorUserIsAlreadyInvited     CONSTANT NUMBER := -20810;
      
      /* Admin */
      k_ErrorStatisticTypeUnassigned CONSTANT NUMBER := -20700;
      k_ErrorUserNotAdmin            CONSTANT NUMBER := -20701;
      k_ErrorUserHasFlagged          CONSTANT NUMBER := -20702;
      k_ErrorMessageReviewed         CONSTANT NUMBER := -20703;
      k_ErrorUserNotFlaggedMessage   CONSTANT NUMBER := -20704;
      k_ErrorNoGroupInformation      CONSTANT NUMBER := -20705;
      k_ErrorEmailAlreadyConfirmed   CONSTANT NUMBER := -20706;
      k_ErrorGroupUserAssignment     CONSTANT NUMBER := -20707;
      k_ErrorGroupMessageAssignment  CONSTANT NUMBER := -20708;
  
  /* Regex */
  k_EmailRegex CONSTANT VARCHAR2(60) := '^[A-Za-z0-9.]+@((students\.)|(faculty\.))?pcci\.edu$';
  k_UserNameRegex CONSTANT VARCHAR2(60) := '^([A-Za-z0-9_]){4,25}$';
  k_PasswordRegex CONSTANT VARCHAR2(17) := '^([^|\n]){8,128}$';

  /* Test Suite constants */
  k_TestUsername  CONSTANT VARCHAR2(17) := 'TestSuiteUsername';
  k_TestPassword  CONSTANT VARCHAR2(8)  := 'Password';
  k_TestPassword2 CONSTANT VARCHAR2(9)  := 'Password2';
  k_TestEmail     CONSTANT VARCHAR2(13) := 'test@test.com';
  k_Pass          CONSTANT VARCHAR2(4)  := 'Pass';

  /* Encryption constants */
  k_NumKeyBytes CONSTANT NUMBER := 256/8; -- Sets number of bytes for a key to 32 bytes
  k_EncryptionType CONSTANT PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;

  /* Messaging Constants */
  k_TooManyMessages CONSTANT NUMBER := 5;
  k_SpamCheckSeconds CONSTANT NUMBER := 15;

  /* Subtypes */
  SUBTYPE t_AuthToken         IS user_information.currenttoken%TYPE;
  SUBTYPE t_Password          IS VARCHAR2(128);
  SUBTYPE t_Username          IS user_information.user_name%TYPE;
  SUBTYPE t_Userrole          IS user_information.user_role%TYPE;
  SUBTYPE t_Email             IS user_information.user_email%TYPE;
  SUBTYPE t_Userid            IS user_information.user_id%TYPE;
  SUBTYPE t_TestResult        IS test_results.result%TYPE;
  SUBTYPE t_MessageText       IS message_text.encrypted_text%TYPE;
  SUBTYPE t_FileText          IS message_file.encrypted_file%TYPE;
  SUBTYPE t_GroupId           IS message_group.group_id%TYPE;
  SUBTYPE t_TextId            IS message_text.text_id%TYPE;
  SUBTYPE t_FileId            IS message_file.file_id%TYPE;
  SUBTYPE t_NestCryptKey      IS message_group.crypto_key%TYPE;
  SUBTYPE t_GroupName         IS message_group.group_name%TYPE;
  SUBTYPE t_LocalRole         IS invitation_table.local_role%TYPE;
  SUBTYPE t_MessagePermission IS message_text.permission_role%TYPE;
  SUBTYPE t_PassCode          IS user_information.user_passcode%TYPE;
  SUBTYPE t_FileExtension     IS message_file.extension%TYPE;
  SUBTYPE t_IconId            IS user_icons.icon_id%TYPE;
  SUBTYPE t_NotifBody         IS notifications.notif_body%TYPE;
END DEFINITIONS;

/
--------------------------------------------------------
--  DDL for Package DEV_TEMPLATES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."DEV_TEMPLATES" AS 

  /* Create a procedure
  
    CREATE PROCEDURE name (
        p_ParameterOne DATATYPE,
        p_ParameterTwo DATATYPE
    )
    AS
        v_LocalVariable DATATYPE;
    BEGIN
        ...
    END;
    
  */ 
  
  /* get all messages, sorted by group and time sent
  SELECT
    mt.text_id,
    mt.time_sent,
    mt.group_id,
    mg.group_name,
    ui.user_id,
    ui.user_name,
    ui.user_email,
    ui.user_id,
    security.decrypt_message(mt.encrypted_text, mg.crypto_key) as msg_text
FROM
    message_text mt
    INNER JOIN user_information ui ON mt.user_id = ui.user_id
    INNER JOIN message_group    mg ON mg.group_id = mt.group_id

ORDER BY
    mg.group_id,
    mt.text_id
  */

END DEV_TEMPLATES;

/
--------------------------------------------------------
--  DDL for Package MESSAGING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."MESSAGING" AS 

    /*******************************************/
    /*       Assertion procedures go here      */
    /*******************************************/
    PROCEDURE assertUserPermissions (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_GroupId);
    
    PROCEDURE AssertUserIsMessageOwner (
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
        
    PROCEDURE assertUserInGroup (
        p_user_id  definitions.t_UserId,
        p_group_id definitions.t_GroupId);
    
    PROCEDURE assertUsernameIDMatch (
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserId);
        
    PROCEDURE assertMessageExists (
        p_text_id definitions.t_TextId);
        
    PROCEDURE AssertFileType(
        p_Extension definitions.t_FileExtension);
        
    PROCEDURE AssertNotSpamming (
        p_UserID definitions.t_UserId);

    /*******************************************/
    /* Standard Messaging Functions/Procedures */
    /*******************************************/
    /* Adds a new message. */
    PROCEDURE send_message (
        p_user_id      definitions.t_UserId,
        p_text         VARCHAR2,
        p_file         CLOB DEFAULT NULL,
        p_FileName     VARCHAR2 DEFAULT '',
        p_Extension    VARCHAR2 DEFAULT '',
        p_group_id     definitions.t_GroupId,
        p_message_role definitions.t_MessagePermission DEFAULT 3);

    FUNCTION GetFile (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId)
    RETURN SYS_REFCURSOR;

    FUNCTION GetFileMetadata (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId
    ) RETURN SYS_REFCURSOR;

    /* Sends message ids in a group. */   
    FUNCTION get_message_ids (
        p_group_id definitions.t_GroupId,
        p_user_id  definitions.t_UserId)
    RETURN SYS_REFCURSOR;

    /* User message retrieval. */
    FUNCTION message_retrieval (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_groupId)
    RETURN VARCHAR2;
    
    /* Set message permission */
    PROCEDURE set_message_permission (
        p_user_id    definitions.t_UserId,
        p_text_id    definitions.t_TextId,
        p_permission definitions.t_MessagePermission);

  FUNCTION get_all_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR;

  FUNCTION get_new_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR;
    
    PROCEDURE DeleteMessage (
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId,
        p_NestId definitions.t_GroupId);
    
    FUNCTION MessageOwner(
        p_TextId definitions.t_TextId)
     RETURN NUMBER;

END MESSAGING;

/

  GRANT EXECUTE ON "CS414_TEAM2"."MESSAGING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package NESTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."NESTS" AS 

    /*******************************************/
    /*       Assertion procedures go here      */
    /*******************************************/
    PROCEDURE assertNestExists (
        p_NestID definitions.t_GroupId
    );
    
    PROCEDURE AssertUserInNestAlready (
        p_UserID definitions.t_UserId,
        p_NestID definitions.t_GroupId
    );
    
    /*******************************************/
    /*   Standard Nest Functions/Procedures    */
    /*******************************************/

  FUNCTION NestExists (
    p_NestID definitions.t_GroupId
  )
  RETURN VARCHAR2;
  
  FUNCTION GetUserRole (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  )
  RETURN NUMBER;

  PROCEDURE CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId,
    o_GroupId OUT definitions.t_GroupId
  );
  
  FUNCTION CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId
  )RETURN NUMBER;

  PROCEDURE AddToNest (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalRole definitions.t_LocalRole DEFAULT 3,
    p_RequestingUser definitions.t_UserId DEFAULT NULL
  );

  PROCEDURE RemoveFromNest (
    p_RemovedUserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_RequestingUser definitions.t_UserId
  );
  
  PROCEDURE LeaveNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  );

  PROCEDURE DeleteGroupNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserID
  );

  PROCEDURE CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  );
  
  FUNCTION CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  ) RETURN NUMBER;

  FUNCTION GetNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetGroupNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetPrivateNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetNestsWithNotifications (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;

  FUNCTION GetNestMembers (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN SYS_REFCURSOR;

  FUNCTION GetNestName (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
   FUNCTION GetUserInvites (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION IsNestPrivate (
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  FUNCTION IsUserInvited (
      p_InvitedUserID definitions.t_UserId,
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  PROCEDURE AcceptGroupInvitation (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_Decision VARCHAR2
  );
  
  PROCEDURE NotifyUser (
    p_UserID definitions.t_UserId
  );  
  
  FUNCTION HasNewMessages(
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  ) RETURN VARCHAR2;
  
  FUNCTION GetMemberCounts(
    p_NestID definitions.t_GroupId
  ) RETURN NUMBER;
  
  PROCEDURE GrantLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  );
  
  PROCEDURE RevokeLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  );
  
  PROCEDURE ToggleNestMute (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  );

  FUNCTION UserHasNestMuted (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

  PROCEDURE ToggleNestLock (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  );

  FUNCTION NestIsLocked (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  FUNCTION NestIsVisible (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

  FUNCTION UserIsKicked (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

END NESTS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NESTS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package NOTIFICATION_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."NOTIFICATION_API" AS 

    PROCEDURE SendNotification (
        p_UserId definitions.t_UserId,
        p_NotifBody definitions.t_NotifBody
    );
    
  FUNCTION GetNotifications (
    p_UserId definitions.t_UserId
  ) RETURN SYS_REFCURSOR;


  FUNCTION UserHasNewNotifications (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

END NOTIFICATION_API;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NOTIFICATION_API" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package SEARCHING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."SEARCHING" AS 

    /*********************************/
    /* Standard functions/procedures */
    /*********************************/ 
    /* Search a user  */
    FUNCTION search_username(p_username definitions.t_Username)
    RETURN SYS_REFCURSOR;
    
    FUNCTION invite_username(p_username definitions.t_Username, p_NestId definitions.t_GroupId)
    RETURN SYS_REFCURSOR;
    
    FUNCTION SearchForNest(
        p_NestName definitions.t_GroupName DEFAULT '',
        p_NestId definitions.t_GroupId     DEFAULT '')
    RETURN SYS_REFCURSOR;
    
    FUNCTION IsInvited(
        p_username definitions.t_Username,
        p_NestId definitions.t_GroupId)
    RETURN VARCHAR2;
    
END SEARCHING;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SEARCHING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package SECURITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."SECURITY" AS
    /*********************************/
    /* Assertion procedures go here  */
    /*********************************/
    PROCEDURE assertUsernameExists (
        p_username definitions.t_Username);
    
    PROCEDURE assertUsernameFree (
        p_username definitions.t_Username);

    PROCEDURE assertEmailFree (
        p_email definitions.t_Email);
        
    PROCEDURE assertEmailExists (
        p_email definitions.t_Email);
        
    PROCEDURE assertUserIdExists (
        p_id definitions.t_UserId);
        
    PROCEDURE assertUserLoginAttempts(
        p_username definitions.t_Username);
    
    PROCEDURE AssertEmailIsConfirmed (
        p_username definitions.t_Username);
        
    PROCEDURE AssertUserIsntBanned (
        p_username definitions.t_Username);
  
    /*********************************/
    /* Standard functions/procedures */
    /*********************************/
    /* Adds a new user  */   
    PROCEDURE add_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password,
        p_email    definitions.t_Email);
                      
    /* Changes current password with new passwords */
    PROCEDURE change_password (
        p_username     definitions.t_Username,
        p_new_password definitions.t_Password,
        p_old_password definitions.t_Password DEFAULT '',
        p_passcode     definitions.t_Passcode DEFAULT '');
    
    /*  Returns user passwords as hash value  */
    FUNCTION create_pass_hash (
        p_identifier VARCHAR2, 
        p_password   VARCHAR2)
    RETURN VARCHAR2;
    
    /* Returns a user's ID */
    FUNCTION get_user_id (
        p_username definitions.t_Username)
    RETURN definitions.t_Userid;
    
    /* Return one time passcode. */
    FUNCTION return_passcode (
        p_email    definitions.t_Email,
        p_username definitions.t_Username)
    RETURN VARCHAR2;
    
    /* Store one time passcode. */
    PROCEDURE update_passcode (
        p_email    definitions.t_Email,
        p_username definitions.t_Username);
    
    /* Set a user's email confirmation to 'Y' if the passcode matches. */
    PROCEDURE ConfirmEmailAddress(
        p_email    definitions.t_Email,
        p_passcode definitions.t_Passcode);
      
    /* Gets the hash for the current login token. */
    FUNCTION create_token_hash (
        p_username definitions.t_Username,
        p_lastlog  TIMESTAMP)
    RETURN VARCHAR2;
    
    PROCEDURE DecryptFile (
        p_Destination IN OUT CLOB,
        p_EncryptedData BLOB,
        p_Key definitions.t_NestCryptKey);
    
    FUNCTION decrypt_message (
        p_message definitions.t_MessageText,
        p_key     definitions.t_NestCryptKey)
    RETURN VARCHAR2;
    
    FUNCTION encrypt_message (
        p_message VARCHAR2,
        p_key     definitions.t_NestCryptKey)
    RETURN RAW;
    
    /* Attempts to log in a user with given information. */
    PROCEDURE login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N');
      
    /* Attempts to log in a user, returns login token. */
    FUNCTION login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N')
    RETURN VARCHAR2;
      
    /* Logs out a user. */
    PROCEDURE logout_user (
        p_username definitions.t_Username);
      
    PROCEDURE LogUserActivity (
        p_UserId definitions.t_UserId
    );
      
    /* Returns 'Y' if given token matches one on file. */
    FUNCTION valid_token(
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2;
      
    /* Checks if username and password matches */
    PROCEDURE valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password);
      
    /* Returns validated username and password */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password)
    RETURN VARCHAR2;
      
    /* Returns whether given login token matches current token. */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2;  

    FUNCTION IsActive (
        p_username definitions.t_Username
    )
    RETURN VARCHAR2;
    
    PROCEDURE is_admin(
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserID);
        
    PROCEDURE LogoutInactiveUsers;

  PROCEDURE EncryptFile (
    p_Destination IN OUT BLOB,
    p_Base64 CLOB,
    p_Key definitions.t_NestCryptKey);

END;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SECURITY" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."STATISTICS" AS 

    /*******************************************/
    /*     Statisitic Selection Function       */
    /*******************************************/
    /* Statistic Selection Function. */  
    FUNCTION gather_statistics (
        p_statistic_type VARCHAR2 DEFAULT NULL,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL,
        p_group_id definitions.t_GroupId DEFAULT NULL,
        p_user_id definitions.t_UserId DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /*******************************************/
    /* Standard Statisitic Gathering Functions */
    /*******************************************/
    /* Run statistics on message count. */  
    FUNCTION message_count (
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on most active group. */  
    FUNCTION most_active_group(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on a specific groups . */ 
    FUNCTION get_group_message_count(
        p_group_id definitions.t_GroupId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on most active user. */ 
    FUNCTION most_active_user(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on a specific users. */
    FUNCTION get_user_message_count(
        p_user_id definitions.t_UserId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;

END STATISTICS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."STATISTICS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package TESTING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."TESTING" AS 
  FUNCTION GetLatestResults
    RETURN SYS_REFCURSOR;
    
  PROCEDURE RunTests;

  FUNCTION TestAddUser
    RETURN VARCHAR2;
    
  FUNCTION TestChangePassword
    RETURN VARCHAR2;
    
  FUNCTION TestLoginUser
    RETURN VARCHAR2;
    
  FUNCTION TestLogoutUser
    RETURN VARCHAR2;
    
  FUNCTION TestCreatePassHash
    RETURN VARCHAR2;

  FUNCTION TestCreateTokenHash
    RETURN VARCHAR2;
    
  FUNCTION TestSearchUser
    RETURN VARCHAR2;

  FUNCTION TestSendMessage
    RETURN VARCHAR2;

  FUNCTION TestCreateGroup
    RETURN VARCHAR2;
    
  FUNCTION TestSendFile
    RETURN VARCHAR2;

  FUNCTION TestDeleteGroup
    RETURN VARCHAR2;
    
  FUNCTION TestKickUser
    RETURN VARCHAR2;
    
END TESTING;

/
--------------------------------------------------------
--  DDL for Package USER_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."USER_SETTINGS" AS 

  FUNCTION GetUserIcon (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

  PROCEDURE AssignRandomProfileIcons;
  
  FUNCTION GetAllUserIcons
  RETURN SYS_REFCURSOR;
  
  PROCEDURE ChangeUserIcon (
    p_UserId definitions.t_UserId,
    p_IconId definitions.t_IconId
  );
  
  FUNCTION GetUserSystemRole (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

  FUNCTION UserIsBanned (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

END USER_SETTINGS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."USER_SETTINGS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package DEFINITIONS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."DEFINITIONS" AS 
  /* Error code constants */
      /* Any page */
      k_ErrorNoPassNoToken     CONSTANT NUMBER := -20000;
      k_ErrorInvalidToken      CONSTANT NUMBER := -20001;
      k_ErrorUserDoesNotExist  CONSTANT NUMBER := -20002;
      k_ErrorEmailDoesNotExist CONSTANT NUMBER := -20003;
      
      /* Registration */
      k_ErrorUserExistsAlready  CONSTANT NUMBER := -20100;
      k_ErrorEmailExistsAlready CONSTANT NUMBER := -20101;
      k_ErrorInvalidEmail       CONSTANT NUMBER := -20102;
      k_ErrorInvalidUsername    CONSTANT NUMBER := -20103;
      
      /* Login */
      k_ErrorInvalidUserPass   CONSTANT NUMBER := -20200;
      k_ErrorAlreadyLoggedIn   CONSTANT NUMBER := -20201;
      k_ErrorEmailNotConfirmed CONSTANT NUMBER := -20202;
      k_ErrorUserHasBeenBanned CONSTANT NUMBER := -20203;
      
      /* Permissions */
      k_ErrorUserDoesNotHavePermission CONSTANT NUMBER := -20300;
      k_ErrorUserIsNotMessageOwner     CONSTANT NUMBER := -20301;
      
      /* Messages */
      k_ErrorNoNewMessages       CONSTANT NUMBER := -20400;
      k_ErrorWrongFileType       CONSTANT NUMBER := -20401;
      k_ErrorMessageDoesNotExist CONSTANT NUMBER := -20402;
      k_ErrorSpam                CONSTANT NUMBER := -20403;
      k_NestIsLocked             CONSTANT NUMBER := -20404;
      
      /* Pasword Change */
      k_ErrorNoPassNoCode        CONSTANT NUMBER := -20500;
      k_ErrorInvalidUserPasscode CONSTANT NUMBER := -20501;
      
      /* Nests */
      k_ErrorNestDoesNotExist         CONSTANT NUMBER := -20600;
      k_ErrorPrivateNestExistsAlready CONSTANT NUMBER := -20601;
      k_ErrorUserIsNotInAGroup        CONSTANT NUMBER := -20602;
      k_ErrorUsernameIsNull           CONSTANT NUMBER := -20603;
      k_ErrorGroupNameInvalid         CONSTANT NUMBER := -20604;
      k_ErrorTooManyNestsCreated      CONSTANT NUMBER := -20605;
      k_ErrorUserHasNoInvites         CONSTANT NUMBER := -20606;
      k_ErrorAcceptOrRejectInvitation CONSTANT NUMBER := -20607;
      k_ErrorUserInNestAlready        CONSTANT NUMBER := -20608;
      k_ErrorUserNotInGroup           CONSTANT NUMBER := -20809;
      k_ErrorUserIsAlreadyInvited     CONSTANT NUMBER := -20810;
      
      /* Admin */
      k_ErrorStatisticTypeUnassigned CONSTANT NUMBER := -20700;
      k_ErrorUserNotAdmin            CONSTANT NUMBER := -20701;
      k_ErrorUserHasFlagged          CONSTANT NUMBER := -20702;
      k_ErrorMessageReviewed         CONSTANT NUMBER := -20703;
      k_ErrorUserNotFlaggedMessage   CONSTANT NUMBER := -20704;
      k_ErrorNoGroupInformation      CONSTANT NUMBER := -20705;
      k_ErrorEmailAlreadyConfirmed   CONSTANT NUMBER := -20706;
      k_ErrorGroupUserAssignment     CONSTANT NUMBER := -20707;
      k_ErrorGroupMessageAssignment  CONSTANT NUMBER := -20708;
  
  /* Regex */
  k_EmailRegex CONSTANT VARCHAR2(60) := '^[A-Za-z0-9.]+@((students\.)|(faculty\.))?pcci\.edu$';
  k_UserNameRegex CONSTANT VARCHAR2(60) := '^([A-Za-z0-9_]){4,25}$';
  k_PasswordRegex CONSTANT VARCHAR2(17) := '^([^|\n]){8,128}$';

  /* Test Suite constants */
  k_TestUsername  CONSTANT VARCHAR2(17) := 'TestSuiteUsername';
  k_TestPassword  CONSTANT VARCHAR2(8)  := 'Password';
  k_TestPassword2 CONSTANT VARCHAR2(9)  := 'Password2';
  k_TestEmail     CONSTANT VARCHAR2(13) := 'test@test.com';
  k_Pass          CONSTANT VARCHAR2(4)  := 'Pass';

  /* Encryption constants */
  k_NumKeyBytes CONSTANT NUMBER := 256/8; -- Sets number of bytes for a key to 32 bytes
  k_EncryptionType CONSTANT PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;

  /* Messaging Constants */
  k_TooManyMessages CONSTANT NUMBER := 5;
  k_SpamCheckSeconds CONSTANT NUMBER := 15;

  /* Subtypes */
  SUBTYPE t_AuthToken         IS user_information.currenttoken%TYPE;
  SUBTYPE t_Password          IS VARCHAR2(128);
  SUBTYPE t_Username          IS user_information.user_name%TYPE;
  SUBTYPE t_Userrole          IS user_information.user_role%TYPE;
  SUBTYPE t_Email             IS user_information.user_email%TYPE;
  SUBTYPE t_Userid            IS user_information.user_id%TYPE;
  SUBTYPE t_TestResult        IS test_results.result%TYPE;
  SUBTYPE t_MessageText       IS message_text.encrypted_text%TYPE;
  SUBTYPE t_FileText          IS message_file.encrypted_file%TYPE;
  SUBTYPE t_GroupId           IS message_group.group_id%TYPE;
  SUBTYPE t_TextId            IS message_text.text_id%TYPE;
  SUBTYPE t_FileId            IS message_file.file_id%TYPE;
  SUBTYPE t_NestCryptKey      IS message_group.crypto_key%TYPE;
  SUBTYPE t_GroupName         IS message_group.group_name%TYPE;
  SUBTYPE t_LocalRole         IS invitation_table.local_role%TYPE;
  SUBTYPE t_MessagePermission IS message_text.permission_role%TYPE;
  SUBTYPE t_PassCode          IS user_information.user_passcode%TYPE;
  SUBTYPE t_FileExtension     IS message_file.extension%TYPE;
  SUBTYPE t_IconId            IS user_icons.icon_id%TYPE;
  SUBTYPE t_NotifBody         IS notifications.notif_body%TYPE;
END DEFINITIONS;

/
--------------------------------------------------------
--  DDL for Package ADMIN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."ADMIN" AS 

   PROCEDURE IsAdmin (
        p_UserName definitions.t_Username,
        p_UserId   definitions.t_UserID);
   
   FUNCTION GetBannedUsers (
        p_UserName definitions.t_UserName,
        p_UserID   definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetFlaggedMessages (
       p_UserName definitions.t_Username,
       p_UserId   definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedNestMessages (
      p_UserName definitions.t_Username,
      p_GroupId definitions.t_GroupId,
      p_UserId definitions.t_userId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedNestMembers (
      p_UserId definitions.t_userId,
      p_GroupId definitions.t_GroupId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetSelectedUserMessages (
     p_UserId definitions.t_UserId)
   RETURN SYS_REFCURSOR;
   
   FUNCTION GetAllUsers (
       p_UserName definitions.t_Username,
       p_UserId   definitions.t_UserId)
   RETURN SYS_REFCURSOR;

    PROCEDURE FlagMessage(
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
        
    PROCEDURE UnFlagMessage(
        p_UserName definitions.t_UserName,
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
   
    FUNCTION MessageFlaggedByUser(
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId)
    RETURN VARCHAR2;
    
    PROCEDURE BanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
    PROCEDURE UnBanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
    PROCEDURE ConfirmUserEmail (
        p_UserEmail definitions.t_Email,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName);
        
END ADMIN;

/

  GRANT EXECUTE ON "CS414_TEAM2"."ADMIN" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package NOTIFICATION_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."NOTIFICATION_API" AS 

    PROCEDURE SendNotification (
        p_UserId definitions.t_UserId,
        p_NotifBody definitions.t_NotifBody
    );
    
  FUNCTION GetNotifications (
    p_UserId definitions.t_UserId
  ) RETURN SYS_REFCURSOR;


  FUNCTION UserHasNewNotifications (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

END NOTIFICATION_API;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NOTIFICATION_API" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package SECURITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."SECURITY" AS
    /*********************************/
    /* Assertion procedures go here  */
    /*********************************/
    PROCEDURE assertUsernameExists (
        p_username definitions.t_Username);
    
    PROCEDURE assertUsernameFree (
        p_username definitions.t_Username);

    PROCEDURE assertEmailFree (
        p_email definitions.t_Email);
        
    PROCEDURE assertEmailExists (
        p_email definitions.t_Email);
        
    PROCEDURE assertUserIdExists (
        p_id definitions.t_UserId);
        
    PROCEDURE assertUserLoginAttempts(
        p_username definitions.t_Username);
    
    PROCEDURE AssertEmailIsConfirmed (
        p_username definitions.t_Username);
        
    PROCEDURE AssertUserIsntBanned (
        p_username definitions.t_Username);
  
    /*********************************/
    /* Standard functions/procedures */
    /*********************************/
    /* Adds a new user  */   
    PROCEDURE add_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password,
        p_email    definitions.t_Email);
                      
    /* Changes current password with new passwords */
    PROCEDURE change_password (
        p_username     definitions.t_Username,
        p_new_password definitions.t_Password,
        p_old_password definitions.t_Password DEFAULT '',
        p_passcode     definitions.t_Passcode DEFAULT '');
    
    /*  Returns user passwords as hash value  */
    FUNCTION create_pass_hash (
        p_identifier VARCHAR2, 
        p_password   VARCHAR2)
    RETURN VARCHAR2;
    
    /* Returns a user's ID */
    FUNCTION get_user_id (
        p_username definitions.t_Username)
    RETURN definitions.t_Userid;
    
    /* Return one time passcode. */
    FUNCTION return_passcode (
        p_email    definitions.t_Email,
        p_username definitions.t_Username)
    RETURN VARCHAR2;
    
    /* Store one time passcode. */
    PROCEDURE update_passcode (
        p_email    definitions.t_Email,
        p_username definitions.t_Username);
    
    /* Set a user's email confirmation to 'Y' if the passcode matches. */
    PROCEDURE ConfirmEmailAddress(
        p_email    definitions.t_Email,
        p_passcode definitions.t_Passcode);
      
    /* Gets the hash for the current login token. */
    FUNCTION create_token_hash (
        p_username definitions.t_Username,
        p_lastlog  TIMESTAMP)
    RETURN VARCHAR2;
    
    PROCEDURE DecryptFile (
        p_Destination IN OUT CLOB,
        p_EncryptedData BLOB,
        p_Key definitions.t_NestCryptKey);
    
    FUNCTION decrypt_message (
        p_message definitions.t_MessageText,
        p_key     definitions.t_NestCryptKey)
    RETURN VARCHAR2;
    
    FUNCTION encrypt_message (
        p_message VARCHAR2,
        p_key     definitions.t_NestCryptKey)
    RETURN RAW;
    
    /* Attempts to log in a user with given information. */
    PROCEDURE login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N');
      
    /* Attempts to log in a user, returns login token. */
    FUNCTION login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N')
    RETURN VARCHAR2;
      
    /* Logs out a user. */
    PROCEDURE logout_user (
        p_username definitions.t_Username);
      
    PROCEDURE LogUserActivity (
        p_UserId definitions.t_UserId
    );
      
    /* Returns 'Y' if given token matches one on file. */
    FUNCTION valid_token(
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2;
      
    /* Checks if username and password matches */
    PROCEDURE valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password);
      
    /* Returns validated username and password */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password)
    RETURN VARCHAR2;
      
    /* Returns whether given login token matches current token. */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2;  

    FUNCTION IsActive (
        p_username definitions.t_Username
    )
    RETURN VARCHAR2;
    
    PROCEDURE is_admin(
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserID);
        
    PROCEDURE LogoutInactiveUsers;

  PROCEDURE EncryptFile (
    p_Destination IN OUT BLOB,
    p_Base64 CLOB,
    p_Key definitions.t_NestCryptKey);

END;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SECURITY" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package USER_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."USER_SETTINGS" AS 

  FUNCTION GetUserIcon (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

  PROCEDURE AssignRandomProfileIcons;
  
  FUNCTION GetAllUserIcons
  RETURN SYS_REFCURSOR;
  
  PROCEDURE ChangeUserIcon (
    p_UserId definitions.t_UserId,
    p_IconId definitions.t_IconId
  );
  
  FUNCTION GetUserSystemRole (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

  FUNCTION UserIsBanned (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2;

END USER_SETTINGS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."USER_SETTINGS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package MESSAGING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."MESSAGING" AS 

    /*******************************************/
    /*       Assertion procedures go here      */
    /*******************************************/
    PROCEDURE assertUserPermissions (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_GroupId);
    
    PROCEDURE AssertUserIsMessageOwner (
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId);
        
    PROCEDURE assertUserInGroup (
        p_user_id  definitions.t_UserId,
        p_group_id definitions.t_GroupId);
    
    PROCEDURE assertUsernameIDMatch (
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserId);
        
    PROCEDURE assertMessageExists (
        p_text_id definitions.t_TextId);
        
    PROCEDURE AssertFileType(
        p_Extension definitions.t_FileExtension);
        
    PROCEDURE AssertNotSpamming (
        p_UserID definitions.t_UserId);

    /*******************************************/
    /* Standard Messaging Functions/Procedures */
    /*******************************************/
    /* Adds a new message. */
    PROCEDURE send_message (
        p_user_id      definitions.t_UserId,
        p_text         VARCHAR2,
        p_file         CLOB DEFAULT NULL,
        p_FileName     VARCHAR2 DEFAULT '',
        p_Extension    VARCHAR2 DEFAULT '',
        p_group_id     definitions.t_GroupId,
        p_message_role definitions.t_MessagePermission DEFAULT 3);

    FUNCTION GetFile (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId)
    RETURN SYS_REFCURSOR;

    FUNCTION GetFileMetadata (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId
    ) RETURN SYS_REFCURSOR;

    /* Sends message ids in a group. */   
    FUNCTION get_message_ids (
        p_group_id definitions.t_GroupId,
        p_user_id  definitions.t_UserId)
    RETURN SYS_REFCURSOR;

    /* User message retrieval. */
    FUNCTION message_retrieval (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_groupId)
    RETURN VARCHAR2;
    
    /* Set message permission */
    PROCEDURE set_message_permission (
        p_user_id    definitions.t_UserId,
        p_text_id    definitions.t_TextId,
        p_permission definitions.t_MessagePermission);

  FUNCTION get_all_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR;

  FUNCTION get_new_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR;
    
    PROCEDURE DeleteMessage (
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId,
        p_NestId definitions.t_GroupId);
    
    FUNCTION MessageOwner(
        p_TextId definitions.t_TextId)
     RETURN NUMBER;

END MESSAGING;

/

  GRANT EXECUTE ON "CS414_TEAM2"."MESSAGING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package NESTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."NESTS" AS 

    /*******************************************/
    /*       Assertion procedures go here      */
    /*******************************************/
    PROCEDURE assertNestExists (
        p_NestID definitions.t_GroupId
    );
    
    PROCEDURE AssertUserInNestAlready (
        p_UserID definitions.t_UserId,
        p_NestID definitions.t_GroupId
    );
    
    /*******************************************/
    /*   Standard Nest Functions/Procedures    */
    /*******************************************/

  FUNCTION NestExists (
    p_NestID definitions.t_GroupId
  )
  RETURN VARCHAR2;
  
  FUNCTION GetUserRole (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  )
  RETURN NUMBER;

  PROCEDURE CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId,
    o_GroupId OUT definitions.t_GroupId
  );
  
  FUNCTION CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId
  )RETURN NUMBER;

  PROCEDURE AddToNest (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalRole definitions.t_LocalRole DEFAULT 3,
    p_RequestingUser definitions.t_UserId DEFAULT NULL
  );

  PROCEDURE RemoveFromNest (
    p_RemovedUserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_RequestingUser definitions.t_UserId
  );
  
  PROCEDURE LeaveNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  );

  PROCEDURE DeleteGroupNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserID
  );

  PROCEDURE CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  );
  
  FUNCTION CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  ) RETURN NUMBER;

  FUNCTION GetNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetGroupNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetPrivateNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION GetNestsWithNotifications (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;

  FUNCTION GetNestMembers (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN SYS_REFCURSOR;

  FUNCTION GetNestName (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
   FUNCTION GetUserInvites (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR;
  
  FUNCTION IsNestPrivate (
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  FUNCTION IsUserInvited (
      p_InvitedUserID definitions.t_UserId,
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  PROCEDURE AcceptGroupInvitation (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_Decision VARCHAR2
  );
  
  PROCEDURE NotifyUser (
    p_UserID definitions.t_UserId
  );  
  
  FUNCTION HasNewMessages(
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  ) RETURN VARCHAR2;
  
  FUNCTION GetMemberCounts(
    p_NestID definitions.t_GroupId
  ) RETURN NUMBER;
  
  PROCEDURE GrantLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  );
  
  PROCEDURE RevokeLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  );
  
  PROCEDURE ToggleNestMute (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  );

  FUNCTION UserHasNestMuted (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

  PROCEDURE ToggleNestLock (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  );

  FUNCTION NestIsLocked (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;
  
  FUNCTION NestIsVisible (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

  FUNCTION UserIsKicked (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2;

END NESTS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NESTS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package SEARCHING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."SEARCHING" AS 

    /*********************************/
    /* Standard functions/procedures */
    /*********************************/ 
    /* Search a user  */
    FUNCTION search_username(p_username definitions.t_Username)
    RETURN SYS_REFCURSOR;
    
    FUNCTION invite_username(p_username definitions.t_Username, p_NestId definitions.t_GroupId)
    RETURN SYS_REFCURSOR;
    
    FUNCTION SearchForNest(
        p_NestName definitions.t_GroupName DEFAULT '',
        p_NestId definitions.t_GroupId     DEFAULT '')
    RETURN SYS_REFCURSOR;
    
    FUNCTION IsInvited(
        p_username definitions.t_Username,
        p_NestId definitions.t_GroupId)
    RETURN VARCHAR2;
    
END SEARCHING;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SEARCHING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."STATISTICS" AS 

    /*******************************************/
    /*     Statisitic Selection Function       */
    /*******************************************/
    /* Statistic Selection Function. */  
    FUNCTION gather_statistics (
        p_statistic_type VARCHAR2 DEFAULT NULL,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL,
        p_group_id definitions.t_GroupId DEFAULT NULL,
        p_user_id definitions.t_UserId DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /*******************************************/
    /* Standard Statisitic Gathering Functions */
    /*******************************************/
    /* Run statistics on message count. */  
    FUNCTION message_count (
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on most active group. */  
    FUNCTION most_active_group(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on a specific groups . */ 
    FUNCTION get_group_message_count(
        p_group_id definitions.t_GroupId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on most active user. */ 
    FUNCTION most_active_user(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;
    
    /* Run statistics on a specific users. */
    FUNCTION get_user_message_count(
        p_user_id definitions.t_UserId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR;

END STATISTICS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."STATISTICS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package TESTING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CS414_TEAM2"."TESTING" AS 
  FUNCTION GetLatestResults
    RETURN SYS_REFCURSOR;
    
  PROCEDURE RunTests;

  FUNCTION TestAddUser
    RETURN VARCHAR2;
    
  FUNCTION TestChangePassword
    RETURN VARCHAR2;
    
  FUNCTION TestLoginUser
    RETURN VARCHAR2;
    
  FUNCTION TestLogoutUser
    RETURN VARCHAR2;
    
  FUNCTION TestCreatePassHash
    RETURN VARCHAR2;

  FUNCTION TestCreateTokenHash
    RETURN VARCHAR2;
    
  FUNCTION TestSearchUser
    RETURN VARCHAR2;

  FUNCTION TestSendMessage
    RETURN VARCHAR2;

  FUNCTION TestCreateGroup
    RETURN VARCHAR2;
    
  FUNCTION TestSendFile
    RETURN VARCHAR2;

  FUNCTION TestDeleteGroup
    RETURN VARCHAR2;
    
  FUNCTION TestKickUser
    RETURN VARCHAR2;
    
END TESTING;

/
--------------------------------------------------------
--  DDL for Package Body ADMIN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."ADMIN" AS

    /* Verifies that an user is an admin. */
    PROCEDURE IsAdmin(
        p_UserName definitions.t_Username,
        p_UserId  definitions.t_UserID)
    AS
        v_Admin VARCHAR2(1) DEFAULT 'N';
    BEGIN
        security.assertUsernameExists(p_UserName);
        
        BEGIN
            SELECT 'Y'
              INTO v_Admin
              FROM user_information
             WHERE user_name = p_UserName
               AND user_id = p_UserId
               AND user_role = 'admin';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Admin := 'N';
        IF v_Admin = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserNotAdmin, 'User ['||p_UserName||'] is not an admin.');
        END IF;
        END;
    END;

    /* Pulls all flagged messages from database */
    FUNCTION GetFlaggedMessages(
        p_UserName definitions.t_Username,
        p_UserId   definitions.t_UserId)
    RETURN SYS_REFCURSOR AS
        c_Messages SYS_REFCURSOR;
    BEGIN
        IsAdmin(p_UserName, p_UserId);

        OPEN c_Messages FOR
            SELECT text_id, msg_text, msg_file, file_id, group_id, time_sent, user_name
             FROM (SELECT message_text.text_id,
                          -- UTL_I18N.RAW_TO_CHAR (encrypted_text, 'WE8ISO8859P1') as msg_text,
                          security.decrypt_message(p_message => encrypted_text, p_key => crypto_key) as msg_text,
                          time_sent,
                          user_name,
                          file_id,
                          group_id,
                          message_file.name || message_file.extension as msg_file,
                          (CASE WHEN file_id IS NOT NULL THEN 0 ELSE 1 END) as ordercol
                     FROM message_text
                     JOIN user_information
                    USING (user_id)
                     LEFT JOIN message_file
                    USING (file_id)
                     JOIN message_group
                    USING (group_id)
                    WHERE report_flag > 0
                      AND (reviewed = 'N' OR reviewed IS NULL)
                    ORDER BY ordercol, time_sent DESC)
             ORDER BY time_sent ASC;
       
        RETURN c_Messages;
    END GetFlaggedMessages;
    
   FUNCTION GetSelectedNestMessages (
      p_UserName definitions.t_Username,
      p_GroupId definitions.t_GroupId,
      p_UserId definitions.t_userId)
   RETURN SYS_REFCURSOR AS
      c_Messages SYS_REFCURSOR;
      v_CryptKey definitions.t_NestCryptKey;
        --v_Activity DATE;
        --v_Checked  DATE;
   BEGIN
      BEGIN
          SELECT crypto_key
            INTO v_CryptKey
            FROM message_group
           WHERE group_id = p_GroupId;
       EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR(definitions.k_ErrorGroupMessageAssignment, 'Issue with Message Assignment.');
      END;
        BEGIN
            OPEN c_Messages FOR
                SELECT text_id, msg_text, msg_file, file_id, reviewed, time_sent, user_name, user_id, user_icon_url, group_id, visible
                 FROM (SELECT message_text.text_id,
                              -- UTL_I18N.RAW_TO_CHAR (encrypted_text, 'WE8ISO8859P1') as msg_text,
                              security.decrypt_message(p_message => encrypted_text, p_key => v_CryptKey) as msg_text,
                              time_sent,
                              reviewed,
                              user_name,
                              user_id,
                              user_settings.GetUserIcon(user_id) AS user_icon_url,
                              file_id,
                              message_file.name || message_file.extension as msg_file,
                              group_id,
                              visible
                         FROM message_text
                         JOIN user_information
                        USING (user_id)
                         LEFT JOIN message_file
                        USING (file_id)
                        WHERE group_id = p_GroupId
                     ORDER BY time_sent DESC)
                     ORDER BY time_sent ASC;
                    EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        RAISE_APPLICATION_ERROR(definitions.k_ErrorGroupMessageAssignment, 'Issue with Message Assignment.');
               END;
        RETURN c_Messages;
      END;
      
      FUNCTION GetSelectedNestMembers (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId
      ) RETURN SYS_REFCURSOR
      AS
        c_Data SYS_REFCURSOR;
      BEGIN
        OPEN c_Data FOR
            SELECT user_id,
                   user_name,
                   banned,
                   group_id,
                   (CASE WHEN local_role = 1 THEN 'Nest Creator' WHEN local_role = 2 THEN 'Admin' ELSE ' ' END) role_string,
                   (CASE WHEN local_role = 1 THEN 'active' WHEN local_role = 2 THEN 'active' ELSE ' ' END) css_class,
                   group_name,
                   user_settings.GetUserIcon(user_id) as user_icon_url,
                   local_role
              FROM user_information
              JOIN invitation_table
             USING (user_id)
              JOIN message_group
             USING (group_id)
             WHERE group_id = p_GroupId
               AND (group_id != -1 AND local_role != 0)
             ORDER BY local_role asc, lower(user_name);
        
        RETURN c_Data;
      END GetSelectedNestMembers;
    
    FUNCTION GetBannedUsers (
        p_UserName definitions.t_UserName,
        p_UserID   definitions.t_UserId) 
    RETURN SYS_REFCURSOR
    AS
        c_Data SYS_REFCURSOR;
    BEGIN
        IsAdmin(p_UserName, p_UserID);
        
        OPEN c_Data FOR
            SELECT user_id,
                   user_name
              FROM user_information
             WHERE banned = 'Y'
             ORDER BY user_name;
        RETURN c_Data;
    END GetBannedUsers;
    
    PROCEDURE FlagMessage(
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId)
    AS
        v_CurrentFlagCount NUMBER;
        v_CurrentReportCount NUMBER;
        v_FlagCountLessThanOne VARCHAR2(1) := 'N';
        v_UserRole definitions.t_UserRole;
        v_FlaggedUserId definitions.t_UserId;
        v_UnencryptedText VARCHAR2(1000);
    BEGIN
       BEGIN
          SELECT user_id
            INTO v_FlaggedUserId
            FROM message_text
           WHERE text_id = p_TextId;
           
          SELECT user_role
            INTO v_UserRole
            FROM user_information
           WHERE user_id = p_UserId;
           
          SELECT report_count
            INTO v_CurrentReportCount
            FROM user_information
           WHERE user_id = v_FlaggedUserId;
       END;
       BEGIN
            SELECT 'N'
              INTO v_FlagCountLessThanOne
              FROM flag_relations
             WHERE user_id = p_UserId
               AND text_id = p_TextId;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_FlagCountLessThanOne := 'Y';
        END;
        
        IF v_FlagCountLessThanOne = 'Y' THEN
            SELECT report_flag
              INTO v_CurrentFlagCount
              FROM message_text
             WHERE text_id = p_TextId;
            
            UPDATE message_text
               SET report_flag = (v_CurrentFlagCount + 1),
                   reviewed = 'N'
             WHERE text_id = p_TextId;
            
            UPDATE user_information
               SET report_count = (v_CurrentReportCount + 1)
             WHERE user_id = v_FlaggedUserId;
            
            INSERT INTO flag_relations (
                user_id,
                text_id
            )
            VALUES (
                p_UserId,
                p_TextId
            );
            IF v_UserRole = 'admin' THEN
                UPDATE message_text
                   SET visible = 'N'
                 WHERE text_id = p_TextId;
            END IF;
            
            COMMIT;
            
            SELECT security.decrypt_message(p_message => encrypted_text, p_key => crypto_key) as msg_text
              INTO v_UnencryptedText
              FROM message_text
              JOIN message_group
             USING (group_id)
             WHERE text_id = p_TextId;
            
            notification_api.SendNotification(
                p_UserId => v_FlaggedUserId,
                p_NotifBody => 'Your message was reported, and an admin will review it shortly. Message: "' || v_UnencryptedText || '"'
            );
        ELSE
             RAISE_APPLICATION_ERROR(definitions.k_ErrorUserHasFlagged, 'User has already flagged this message.');
        END IF;
    END FlagMessage;

  PROCEDURE UnFlagMessage(
        p_UserName definitions.t_UserName,
        p_UserId   definitions.t_UserId,
        p_TextId   definitions.t_TextId
  ) AS
        v_UnencryptedText VARCHAR2(1000);
        v_FlaggedUserId definitions.t_UserId;
        c_UsersWhoReported SYS_REFCURSOR;
  BEGIN
    BEGIN
        UPDATE message_text
           SET report_flag = 0,
               reviewed = 'Y',
               visible = 'Y'
         WHERE text_id = p_TextId;
         
         COMMIT;
        
        SELECT security.decrypt_message(p_message => encrypted_text, p_key => crypto_key) as msg_text
              INTO v_UnencryptedText
              FROM message_text
              JOIN message_group
             USING (group_id)
             WHERE text_id = p_TextId;
        
        FOR v_Row IN (SELECT user_id
                        FROM flag_relations
                       WHERE text_id = p_TextId) LOOP
            notification_api.SendNotification(
               p_UserId => v_Row.user_id,
               p_NotifBody => 'A message you reported was reviewed by an admin and has been approved. Message: "' || v_UnencryptedText || '"'
            );
        END LOOP;
        
        DELETE 
          FROM flag_relations
         WHERE text_id = p_TextId;
         
         COMMIT;
       
         SELECT user_id
           INTO v_FlaggedUserId
           FROM message_text
          WHERE text_id = p_TextId;
         
         notification_api.SendNotification(
            p_UserId => v_FlaggedUserId,
            p_NotifBody => 'Your message was reviewed by an admin and has been approved. Message: "' || v_UnencryptedText || '"'
         );
    END;
  END UnFlagMessage;

   FUNCTION GetAllUsers(
       p_UserName definitions.t_Username,
       p_UserId   definitions.t_UserId)
   RETURN SYS_REFCURSOR AS
  c_Data SYS_REFCURSOR;
  BEGIN
    IsAdmin(p_UserName, p_UserId);
    
    OPEN c_Data FOR
        SELECT user_id,
               user_name,
               user_email,
               report_count,
               banned,
               (CASE WHEN email_confirmation = 'N' THEN 'Email Not Confirmed.' ELSE '' END) email_confirmation,
               (CASE WHEN report_count > 0 THEN 'Report Count ' ||  report_count WHEN report_count < 1 THEN 'Good Pigeon' END) role_string,
               (CASE WHEN banned = 'Y' THEN 'banned' ELSE ' ' END) css_class
          FROM user_information
         ORDER BY banned desc, report_count desc, user_name;
    RETURN c_Data;
  END GetAllUsers;

  FUNCTION MessageFlaggedByUser(
       p_UserId definitions.t_UserId,
       p_TextId definitions.t_TextId)
   RETURN VARCHAR2 AS
      v_HasBeenFlagged VARCHAR2(1) := 'N';
   BEGIN
        security.assertUserIdExists(p_UserId);
        BEGIN
            SELECT 'Y'
              INTO v_HasBeenFlagged
              FROM flag_relations
              JOIN message_text
             USING (text_id)
             WHERE flag_relations.user_id = p_UserId
               AND text_id = p_TextId
               AND report_flag > 0;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_HasBeenFlagged := 'N';
        END;
     RETURN v_HasBeenFlagged;
  END MessageFlaggedByUser;
  
  PROCEDURE BanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName) AS
  BEGIN
     IsAdmin(p_AdminName, p_AdminUserId);
     BEGIN
        UPDATE user_information
           SET banned = 'Y'
         WHERE user_id = p_BannedUserId;
     END;
     COMMIT;
  END BanUser;
  
  PROCEDURE UnBanUser (
        p_BannedUserId definitions.t_UserId,
        p_AdminUserId definitions.t_UserId,
        p_AdminName definitions.t_UserName) AS
  BEGIN
     IsAdmin(p_AdminName, p_AdminUserId);
     BEGIN
        UPDATE user_information
           SET banned = 'N'
         WHERE user_id = p_BannedUserId;
     END;
     COMMIT;
  END UnBanUser;
  
   PROCEDURE ConfirmUserEmail (
      p_UserEmail definitions.t_Email,
      p_AdminUserId definitions.t_UserId,
      p_AdminName definitions.t_UserName)
   AS
      v_PassCode definitions.t_PassCode;
   BEGIN
      IsAdmin(p_AdminName, p_AdminUserId);
      BEGIN
          SELECT user_passcode
            INTO v_PassCode
            FROM user_information
           WHERE user_email = p_UserEmail
             AND email_confirmation = 'N';
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
               RAISE_APPLICATION_ERROR(definitions.k_ErrorEmailAlreadyConfirmed, 'This users email is confirmed.');
      END;
      security.ConfirmEmailAddress(p_UserEmail, v_PassCode);
   END ConfirmUserEmail;

  FUNCTION GetSelectedUserMessages (
     p_UserId definitions.t_UserId)
   RETURN SYS_REFCURSOR AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserId);
  
    OPEN c_Data FOR
          SELECT
                mt.text_id,
                mt.file_id,
                mt.time_sent,
                mt.group_id,
                mg.group_name,
                mf.name as msg_file,
                ui.user_id,
                ui.user_name,
                ui.user_id,
                security.decrypt_message(mt.encrypted_text, mg.crypto_key) as msg_text,
                mt.visible
            FROM
                message_text mt
                INNER JOIN user_information ui ON mt.user_id = ui.user_id
                INNER JOIN message_group    mg ON mg.group_id = mt.group_id
                LEFT JOIN message_file     mf ON mt.file_id = mf.file_id
            WHERE
                ui.user_id = p_UserId
            ORDER BY
                mg.group_id,
                mt.text_id;
                
    RETURN c_Data;
  END GetSelectedUserMessages;

END ADMIN;

/

  GRANT EXECUTE ON "CS414_TEAM2"."ADMIN" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body MESSAGING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."MESSAGING" AS
    
    PROCEDURE AssertNestNotLocked (
        p_NestId definitions.t_GroupId
    ) AS
        v_Locked VARCHAR2(1) DEFAULT 'N';
    BEGIN
        nests.assertNestExists(p_NestId);
        
        SELECT locked_by_admin
          INTO v_Locked
          FROM message_group
         WHERE group_id = p_NestId;
        
        IF v_Locked = 'Y' THEN
            RAISE_APPLICATION_ERROR(definitions.k_NestIsLocked, 'This nest has been locked by an admin, and no new messages can be sent.');
        END IF;
    END;
    
    /* Check that a user has correct permissions. */
    PROCEDURE assertUserPermissions (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_GroupId)
    AS
        v_UserPermitted      VARCHAR2(1) DEFAULT 'N';
        v_message_permission definitions.t_MessagePermission;
        v_local_role         definitions.t_LocalRole;
    BEGIN
        security.assertUserIdExists(p_id => p_user_id);
        assertUserInGroup(p_user_id => p_user_id, p_group_id => p_group_id);
        assertMessageExists(p_text_id => p_text_id);
        
        SELECT permission_role
          INTO v_message_permission
          FROM message_text
         WHERE p_text_id = text_id;

        SELECT local_role
          INTO v_local_role
          FROM invitation_table
         WHERE p_group_id = group_id
           AND p_user_id = user_id;

        IF v_message_permission = v_local_role OR v_local_role <= 2 THEN
            v_UserPermitted := 'Y';
        END IF;

        IF v_UserPermitted = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserDoesNotHavePermission, 'User does not have permission.');
        END IF;
    END;

    /* Check that a user is owner of a message. */
    PROCEDURE AssertUserIsMessageOwner (
        p_UserId definitions.t_UserId,
        p_TextId definitions.t_TextId) 
    AS
        v_UserIsOwner VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_UserIsOwner
              FROM message_text
             WHERE p_TextId = text_id AND p_UserId = user_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UserIsOwner := 'N';
        END;
        IF v_UserIsOwner = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsNotMessageOwner, 'User is not the message owner.');
        END IF;
    END AssertUserIsMessageOwner;
    
    /* Check that a user is in a group. */
    PROCEDURE assertUserInGroup (
        p_user_id  definitions.t_UserId,
        p_group_id definitions.t_GroupId)
    AS
        v_UserInGroup VARCHAR2(1) DEFAULT 'N';
        v_UserIsAdmin VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_UserIsAdmin
              FROM user_information
             WHERE user_id = p_user_id
               AND user_role = 'admin';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UserIsAdmin := 'N';
        END;
        BEGIN
            IF v_UserIsAdmin = 'Y' THEN
                v_UserInGroup := 'Y';
            ELSE
                SELECT 'Y'
                  INTO v_UserInGroup
                  FROM invitation_table
                 WHERE group_id = p_group_id AND p_user_id = user_id;
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UserInGroup := 'N';
        END;

        IF v_UserInGroup = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserNotInGroup, 'User is not in this group.');
        END IF;
    
    END;

    PROCEDURE assertMessageExists (
        p_text_id definitions.t_TextId)
    AS
        v_Exists VARCHAR2(1) DEFAULT 'N';
    BEGIN
        SELECT 'Y'
          INTO v_Exists
          FROM message_text
         WHERE text_id = p_text_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorMessageDoesNotExist, 'Message ['||p_text_id||'] does not exist.');
    END;

    PROCEDURE assertUsernameIDMatch (
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserId)
    AS
        v_UsernameMatchID VARCHAR2(1) DEFAULT 'N';
        v_UserName VARCHAR2(25);
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_UsernameMatchID
              FROM user_information
             WHERE p_username = user_name AND p_user_id = user_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UsernameMatchID := 'N';
        END;

        IF v_UsernameMatchID = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserNotInGroup, 'Username, User ID mismatch illegal call detected.');
        END IF;
    NULL;
    END assertUsernameIDMatch;

    PROCEDURE AssertFileType(
        p_Extension definitions.t_FileExtension)
    AS
        v_Valid VARCHAR2(1);
    BEGIN
        SELECT 'Y'
          INTO v_Valid
          FROM dual
         WHERE p_Extension IN (SELECT EXTENSION FROM FILE_EXTENSIONS);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorWrongFileType, 'Invalid extension given. '||p_Extension||' is not a supported extension.');
    END AssertFileType;

    /* Adds message data from the client into a message text table and */
    /* message file table where applicable.                            */
    PROCEDURE send_message (
        p_user_id      definitions.t_UserId,
        p_text         VARCHAR2,
        p_file         CLOB DEFAULT NULL,
        p_FileName     VARCHAR2 DEFAULT '',
        p_Extension    VARCHAR2 DEFAULT '',
        p_group_id     definitions.t_GroupId,
        p_message_role definitions.t_MessagePermission DEFAULT 3)
    AS
        v_text_id  definitions.t_TextId;
        v_file_id  definitions.t_FileId;
        v_EncryptedFile BLOB := EMPTY_BLOB();
        v_SourceClob CLOB;
        v_CryptoKey definitions.t_NestCryptKey;
        v_UserRole VARCHAR2(20);
        v_MessageIsGoingToPrivateNest VARCHAR2(1);
        v_LocalRole definitions.t_LocalRole;
    BEGIN
        assertUserInGroup(p_user_id, p_group_id);
        AssertNotSpamming(p_user_id);
        AssertNestNotLocked(p_group_id);
        
        v_text_id := text_id.NEXTVAL;
        
        SELECT crypto_key
          INTO v_CryptoKey
          FROM message_group
         WHERE group_id = p_group_id;
        
        INSERT INTO message_text (
            text_id,
            group_id,
            encrypted_text,
            user_id,
            permission_role,
            time_sent
        )
        VALUES (
            v_text_id,
            p_group_id,
            security.encrypt_message(p_text, v_CryptoKey),
            p_user_id,
            p_message_role,
            SYSDATE
        );
        COMMIT;
        
        UPDATE message_group
           SET last_activity = SYSDATE
         WHERE group_id = p_group_id;
        
        security.LogUserActivity(p_user_id);
        
        COMMIT;
        
        IF p_file IS NOT NULL THEN
            AssertFileType(p_Extension);
            
            v_file_id := file_id.NEXTVAL;
            
            v_SourceClob := p_file;
            
            DBMS_LOB.OPEN(v_SourceClob, DBMS_LOB.LOB_READONLY);
            
            DBMS_LOB.CREATETEMPORARY(
                 lob_loc => v_EncryptedFile
               , cache   => true
               , dur     => dbms_lob.session
           );
            
            DBMS_LOB.OPEN(v_EncryptedFile, DBMS_LOB.LOB_READWRITE);
            
            DBMS_CRYPTO.ENCRYPT(dst => v_EncryptedFile,
                                src => v_SourceClob,
                                typ => definitions.k_EncryptionType,
                                key => v_CryptoKey);
            
            DBMS_LOB.CLOSE(v_EncryptedFile);
            DBMS_LOB.CLOSE(v_SourceClob);
            
            INSERT INTO message_file (
                name,
                extension,
                file_id,
                encrypted_file,
                text_id
            )
            VALUES (
                p_FileName,
                p_Extension,
                v_file_id,
                v_EncryptedFile,
                v_text_id
            );
            COMMIT;
            
            SELECT user_role
              INTO v_UserRole
              FROM user_information
             WHERE user_id = p_user_id;
            
            SELECT private
              INTO v_MessageIsGoingToPrivateNest
              FROM message_group
             WHERE group_id = p_group_id;
            
            SELECT local_role
              INTO v_LocalRole
              FROM invitation_table
             WHERE group_id = p_group_id
               AND user_id = p_user_id;
            
            IF (v_UserRole != 'admin' AND v_MessageIsGoingToPrivateNest = 'N') AND v_LocalRole NOT IN (0, 1, 2) THEN
                UPDATE message_text
                   SET file_id = v_file_id,
                       report_flag = 2
                 WHERE text_id = v_text_id;
            ELSE
                UPDATE message_text
                   SET file_id = v_file_id
                 WHERE text_id = v_text_id;
            END IF;
             
            COMMIT;
        END IF;
    END send_message;

    /* Gets all the text ids for a group. */
    FUNCTION get_message_ids (
        p_group_id definitions.t_GroupId,
        p_user_id  definitions.t_UserId)
    RETURN SYS_REFCURSOR
    AS
        sys_var SYS_REFCURSOR;
    BEGIN
        OPEN sys_var FOR SELECT text_id FROM message_text WHERE group_id = p_group_id;
        RETURN sys_var;
    END get_message_ids;
    
    /* Update the permissions on a message. */
    PROCEDURE set_message_permission (
        p_user_id    definitions.t_UserId,
        p_text_id    definitions.t_TextId,
        p_permission definitions.t_MessagePermission)
    AS
    BEGIN
        AssertUserIsMessageOwner(p_user_id, p_text_id);
        UPDATE message_text
           SET permission_role = p_permission
         WHERE text_id = p_text_id;
         COMMIT;
    END set_message_permission;

  FUNCTION get_new_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR AS
    c_Messages SYS_REFCURSOR;
    v_CryptKey definitions.t_NestCryptKey;
    v_Activity DATE;
    v_Checked  DATE;
  BEGIN
    assertUserInGroup(p_group_id => p_group_id, p_user_id => p_user_id);
    --assertUsernameIDMatch(p_username => p_username, p_user_id => p_user_id);
    
    SELECT crypto_key
      INTO v_CryptKey
      FROM message_group
     WHERE group_id = p_group_id;
    
    SELECT last_checked
      INTO v_Checked
      FROM invitation_table
     WHERE user_id = p_user_id
       AND group_id = p_group_id;
    
    OPEN c_Messages FOR
        SELECT text_id, msg_text, msg_file, file_id, reviewed, time_sent, user_name, user_id, user_icon_url, admin.MessageFlaggedByUser(p_user_id, text_id) as has_flagged, DBMS_RANDOM.STRING('X', length(msg_text)) as cypher_text, nests.GetUserRole(user_id, group_id) as local_role
         FROM (SELECT message_text.text_id,
                      -- UTL_I18N.RAW_TO_CHAR (encrypted_text, 'WE8ISO8859P1') as msg_text,
                      security.decrypt_message(p_message => encrypted_text, p_key => v_CryptKey) as msg_text,
                      time_sent,
                      reviewed,
                      user_name,
                      user_id,
                      user_settings.GetUserIcon(user_id) AS user_icon_url,
                      file_id,
                      message_file.name || message_file.extension as msg_file,
                      group_id
                 FROM message_text
                 JOIN user_information
                USING (user_id)
                 LEFT JOIN message_file
                USING (file_id)
                WHERE group_id = p_group_id
                  AND time_sent > v_Checked
                  AND visible = 'Y'
                  AND report_flag < 2
                  AND banned != 'Y'
                ORDER BY time_sent DESC)
         ORDER BY time_sent ASC;
       
    UPDATE invitation_table
       SET last_checked = SYSDATE
     WHERE user_id = p_user_id
       AND group_id = p_group_id;
    
    COMMIT;
    
    RETURN c_Messages;
  END;
  
  FUNCTION get_all_group_messages (
        p_username definitions.t_Username,
        p_group_id definitions.t_GroupId,
        p_user_id definitions.t_userId)
    RETURN SYS_REFCURSOR AS
    c_Messages SYS_REFCURSOR;
    v_CryptKey definitions.t_NestCryptKey;
    --v_Activity DATE;
    --v_Checked  DATE;
  BEGIN
    assertUserInGroup(p_group_id => p_group_id, p_user_id => p_user_id);
    --assertUsernameIDMatch(p_username => p_username, p_user_id => p_user_id);
    
    SELECT crypto_key
      INTO v_CryptKey
      FROM message_group
     WHERE group_id = p_group_id;
    
    OPEN c_Messages FOR
        SELECT text_id, msg_text, msg_file, file_id, reviewed, time_sent, user_name, user_id, user_icon_url, admin.MessageFlaggedByUser(p_user_id, text_id) as has_flagged, DBMS_RANDOM.STRING('X', length(msg_text)) as cypher_text, nests.GetUserRole(user_id, group_id) as local_role
         FROM (SELECT message_text.text_id,
                      -- UTL_I18N.RAW_TO_CHAR (encrypted_text, 'WE8ISO8859P1') as msg_text,
                      security.decrypt_message(p_message => encrypted_text, p_key => v_CryptKey) as msg_text,
                      time_sent,
                      reviewed,
                      user_name,
                      user_id,
                      user_settings.GetUserIcon(user_id) AS user_icon_url,
                      file_id,
                      message_file.name || message_file.extension as msg_file,
                      group_id
                 FROM message_text
                 JOIN user_information
                USING (user_id)
                 LEFT JOIN message_file
                USING (file_id)
                WHERE group_id = p_group_id
                  AND visible = 'Y'
                  AND report_flag < 2
                  AND banned != 'Y'
                ORDER BY time_sent DESC)
         ORDER BY time_sent ASC;
       
    UPDATE invitation_table
       SET last_checked = SYSDATE
     WHERE user_id = p_user_id
       AND group_id = p_group_id;
    
    COMMIT;
    
    RETURN c_Messages;
  END;
  FUNCTION message_retrieval (
        p_user_id  definitions.t_UserId,
        p_text_id  definitions.t_TextId,
        p_group_id definitions.t_groupId)
    RETURN VARCHAR2 AS
    c_Message SYS_REFCURSOR;
    v_CryptKey definitions.t_NestCryptKey;
    v_MessageText definitions.t_MessageText;
    v_Decrypted VARCHAR2(32767);
  BEGIN
    OPEN c_Message FOR SELECT 1 FROM DUAL;
    
    assertUserPermissions(p_user_id, p_text_id, p_group_id);
    
    SELECT crypto_key
      INTO v_CryptKey
      FROM message_group
     WHERE group_id = p_group_id;
    
    SELECT encrypted_text
      INTO v_MessageText
      FROM message_text
     WHERE text_id = p_text_id;
    
    v_Decrypted := security.decrypt_message(p_message => v_MessageText, p_key => v_CryptKey);
    
    OPEN c_Message FOR
      SELECT v_Decrypted as msg_text, mt.file_id, mf.encrypted_file
        FROM message_text mt
        LEFT JOIN message_file mf
          ON mt.text_id = mf.text_id
       WHERE mt.text_id = p_text_id;
    
    RETURN v_Decrypted;
  END message_retrieval;

  FUNCTION GetFile (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId)
    RETURN SYS_REFCURSOR AS
        v_Base64 CLOB := EMPTY_CLOB(); 
        v_Source BLOB := EMPTY_BLOB(); 
        v_CryptoKey definitions.t_NestCryptKey;
        c_Data SYS_REFCURSOR;
  BEGIN
    messaging.assertUserInGroup(p_UserId, p_GroupId);
  
    SELECT crypto_key 
      INTO v_CryptoKey 
      FROM message_group 
     WHERE group_id=p_GroupId; 
  
    SELECT encrypted_file 
      INTO v_Source 
      FROM message_file 
     WHERE file_id = p_FileId; 
      
     DBMS_LOB.OPEN(v_Source, DBMS_LOB.LOB_READONLY); 
             
    DBMS_LOB.CREATETEMPORARY( 
         lob_loc => v_Base64 
       , cache   => true 
       , dur     => dbms_lob.session 
    ); 
     
    DBMS_LOB.OPEN(v_Base64, DBMS_LOB.LOB_READWRITE); 
     
    DBMS_CRYPTO.DECRYPT(dst => v_Base64, 
                        src => v_Source, 
                        typ => definitions.k_EncryptionType, 
                        key => v_CryptoKey); 
     
    DBMS_LOB.CLOSE(v_Base64); 
    DBMS_LOB.CLOSE(v_Source); 

    OPEN c_Data FOR
      SELECT GetFile.v_Base64 "file"
        FROM dual;
        
    RETURN c_Data;
  END GetFile;

  FUNCTION GetFileMetadata (
        p_UserId definitions.t_UserId,
        p_GroupId definitions.t_GroupId,
        p_FileId definitions.t_FileId
    ) RETURN SYS_REFCURSOR AS
    c_Data SYS_REFCURSOR;
  BEGIN
    messaging.assertUserInGroup(p_UserId, p_GroupId);
    
    OPEN c_Data FOR
      SELECT name, extension
        FROM message_file
       WHERE file_id = p_FileId;
    RETURN c_Data;
  END GetFileMetadata;

  PROCEDURE DeleteMessage (
       p_UserId  definitions.t_UserId,
       p_TextId  definitions.t_TextId,
       p_NestId definitions.t_GroupId)
  AS
       v_UserRole VARCHAR(1);
       v_userIsSender VARCHAR(1);
       v_Admin VARCHAR(1);
       v_UnencryptedText VARCHAR2(255);
       v_FlaggedUserId definitions.t_UserId;
  BEGIN
      BEGIN
            SELECT 'Y'
              INTO v_UserRole
              FROM invitation_table
             WHERE user_id = p_UserId
               AND local_role IN(0, 1, 2)
               AND group_id = p_NestId;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UserRole := 'N';
      END;
      BEGIN
            SELECT 'Y'
              INTO v_UserIsSender
              FROM message_text
             WHERE user_id = p_UserId
               AND text_id = p_TextId;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_UserIsSender := 'N';
        END;
        BEGIN
            SELECT 'Y'
              INTO v_Admin
              FROM user_information
             WHERE user_id = p_UserId
               AND user_role = 'admin';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Admin := 'N';
        END;

      BEGIN
            IF(v_UserRole = 'Y' OR v_UserIsSender = 'Y' OR v_Admin = 'Y') THEN
                BEGIN
                    UPDATE message_text
                       SET visible = 'N',
                           reviewed = 'Y'
                     WHERE text_id = p_TextId;  
                    COMMIT;
                     
                     IF v_Admin = 'Y' AND v_UserIsSender = 'N' THEN
                         SELECT security.decrypt_message(p_message => encrypted_text, p_key => crypto_key) as msg_text
                          INTO v_UnencryptedText
                          FROM message_text
                          JOIN message_group
                         USING (group_id)
                         WHERE text_id = p_TextId;
                   
                         SELECT user_id
                           INTO v_FlaggedUserId
                           FROM message_text
                          WHERE text_id = p_TextId;
                          
                         notification_api.SendNotification(
                            p_UserId => v_FlaggedUserId,
                            p_NotifBody => 'Your message was reviewed by an admin and has been deleted. Message: "' || v_UnencryptedText || '"'
                         );
                         
                         FOR v_Row IN (SELECT user_id
                                         FROM flag_relations
                                        WHERE text_id = p_TextId) LOOP
                             notification_api.SendNotification(
                                p_UserId => v_Row.user_id,
                                p_NotifBody => 'A message you reported was reviewed by an admin and has been deleted.'
                             );
                         END LOOP;
                     END IF;
                     
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        NULL;
                    COMMIT;
                END;
            ELSE
                RAISE_APPLICATION_ERROR(definitions.k_ErrorUserDoesNotHavePermission, 'User does not have permission.');
            END IF;
     END;
   END DeleteMessage;
   
  FUNCTION MessageOwner(
        p_TextId definitions.t_TextId)
     RETURN NUMBER AS
        v_UserId definitions.t_UserId;
     BEGIN
        BEGIN
            SELECT user_id
              INTO v_UserId
              FROM message_text
             WHERE p_TextId = text_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                Null;
        END;
    RETURN v_UserId;
  END MessageOwner;

  PROCEDURE AssertNotSpamming (
        p_UserID definitions.t_UserId) AS
    v_RecentMessageCount PLS_INTEGER;
  BEGIN
    
    SELECT COUNT(*)
      INTO v_RecentMessageCount
      FROM message_text
     WHERE user_id = p_UserID
       AND ((SYSDATE - time_sent) * 24 * 60 * 60) <= definitions.k_SpamCheckSeconds;
    
    IF v_RecentMessageCount >= definitions.k_TooManyMessages THEN
        RAISE_APPLICATION_ERROR(definitions.k_ErrorSpam, 'User ['||p_UserID||'] has sent too many messages in the past '||definitions.k_SpamCheckSeconds||' seconds.');
    END IF;
  END AssertNotSpamming;

END MESSAGING;

/

  GRANT EXECUTE ON "CS414_TEAM2"."MESSAGING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body NESTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."NESTS" AS

  PROCEDURE assertNestExists (
    p_NestID definitions.t_GroupId
  ) AS
  BEGIN
    IF NestExists(p_NestID) = 'N' THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorNestDoesNotExist, 'Nest ['||p_NestID||'] does not exist.');
    END IF;
  END;
  
  PROCEDURE AssertUserInNestAlready (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) AS
    v_AlreadyInNest VARCHAR(1);
    v_NestName definitions.t_GroupName;
  BEGIN
    assertNestExists(p_NestID);
    BEGIN
        SELECT group_name
          INTO v_NestName
          FROM message_group
         WHERE p_NestID = group_id;
    END;
    BEGIN
        SELECT 'Y'
          INTO v_AlreadyInNest
          FROM invitation_table
         WHERE user_id = p_UserID
           AND group_id = p_NestID 
           AND invite_status = 'Y';
     EXCEPTION
          WHEN NO_DATA_FOUND THEN
            v_AlreadyInNest := 'N';
    END;

    IF v_AlreadyInNest = 'Y' THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserInNestAlready, 'User is already in ['||v_NestName||'].');
    END IF;
  END;

  PROCEDURE CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  ) AS
    v_GroupId definitions.t_GroupId;
    v_GroupExistsAlready VARCHAR2(1);
  BEGIN
    security.assertUserIdExists(p_UserA);
    security.assertUserIdExists(p_UserB);
    
    -- Check if a private group between the two users exists
    BEGIN
      IF p_UserA != p_UserB THEN
        SELECT 'Y'
        INTO v_GroupExistsAlready
        FROM (SELECT COUNT(*) AS hits
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE private = 'Y'
                 AND user_id IN (p_UserA, p_UserB)
                 AND local_role = 3
               GROUP BY group_id
               ORDER BY hits DESC)
       WHERE rownum = 1
         AND hits = 2;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_GroupExistsAlready := 'N';
    END;
    
    IF v_GroupExistsAlready = 'N' THEN
        v_GroupId := group_id_seq.NEXTVAL;
        
        -- Create the group
        INSERT INTO message_group (
            group_id,
            crypto_key,
            group_name,
            created_by,
            private
        )
        VALUES (
            v_GroupId,
            DBMS_CRYPTO.RANDOMBYTES(definitions.k_NumKeyBytes),            
            p_UserA || ' -> ' || p_UserB,
            p_UserA,
            'Y'
        );
        
        COMMIT;
        
        -- Invite both users to the group
        AddToNest(p_UserID => p_UserA, p_NestID => v_GroupId);
        AddToNest(p_UserID => p_UserB, p_NestID => v_GroupId);
        
        -- Add system admins to group (does not show to the users)
        FOR v_Row IN (SELECT user_id FROM user_information WHERE trim(lower(user_role)) = 'admin') LOOP
            IF v_Row.user_id != p_UserA AND v_Row.user_id != p_UserB THEN
              INSERT INTO invitation_table
              (user_id, group_id, is_invited, local_role, invite_status)
              VALUES
              (v_Row.user_id, v_GroupId, 'Y', 0, 'Y');
              
              COMMIT;
            END IF;
        END LOOP;
    ELSE
        RAISE_APPLICATION_ERROR(definitions.k_ErrorPrivateNestExistsAlready, 'A private Nest between these two users exists already.');
    END IF;
  END;

  PROCEDURE CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId,
    o_GroupId OUT definitions.t_GroupId
  ) AS
        v_GroupId definitions.t_GroupId;
        v_SystemRole VARCHAR2(100);
        v_NestCount NUMBER;
  BEGIN
    UPDATE user_information
       SET nests_created = (SELECT COUNT(*)
                              FROM message_group
                             WHERE created_by = p_User
                               AND private = 'N'
                               AND visible = 'Y')
     WHERE user_id = p_User;
    
    SELECT nests_created
      INTO v_NestCount
      FROM user_information
     WHERE user_id = p_User;
    
    SELECT user_role
          INTO v_SystemRole
          FROM user_information
         WHERE user_id = p_User;
     
    IF v_SystemRole = 'admin' OR v_NestCount < 5 THEN
        v_GroupId := group_id_seq.NEXTVAL;
        
        -- Create the group
        INSERT INTO message_group (
            group_id,
            crypto_key,
            group_name,
            created_by
        )
        VALUES (
            v_GroupId,
            DBMS_CRYPTO.RANDOMBYTES(definitions.k_NumKeyBytes),
            p_Name,
            p_User
        );
        
        COMMIT;
        
        -- Invite all system administrators
        FOR v_Row IN (SELECT user_id FROM user_information WHERE trim(lower(user_role)) = 'admin') LOOP
            INSERT INTO invitation_table(
                user_id,
                group_id,
                is_invited,
                local_role,
                invite_status,
                is_muted)
            VALUES(
                v_Row.user_id,
                v_GroupId,
                'Y',
                0,
                'Y',
                'Y');
                
            COMMIT;
        END LOOP;
    
        -- Invite the creator, with permission '1'    
        IF v_SystemRole != 'admin' THEN
            INSERT INTO invitation_table(
                user_id,
                group_id,
                is_invited,
                local_role,
                invite_status,
                is_muted)
            VALUES(
                p_User,
                v_GroupId,
                'Y',
                1,
                'Y',
                'N');
                
            COMMIT;
        END IF;
        UPDATE user_information
           SET nests_created = v_NestCount + 1
         WHERE user_id = p_User;
        o_GroupId := v_GroupId;
    ELSE
        RAISE_APPLICATION_ERROR(definitions.k_ErrorTooManyNestsCreated, 'You have made the most amount of nests: ['||v_NestCount||'].');
    END IF;
  END CreateNest;
  
  FUNCTION CreateNest (
    p_Name definitions.t_GroupName,
    p_User definitions.t_UserId
  ) RETURN NUMBER AS
   v_NewGroupId definitions.t_GroupId;
  BEGIN
    CreateNest(p_Name, p_User, v_NewGroupId);
    
    RETURN v_NewGroupId;
  END CreateNest;

  PROCEDURE AddToNest (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalRole definitions.t_LocalRole DEFAULT 3,
    p_RequestingUser definitions.t_UserId DEFAULT NULL
  ) AS
    v_AlreadyHasInvite VARCHAR2(1);
    v_NestIsPrivate    VARCHAR2(1);
    v_PrivateCount     PLS_INTEGER;
    v_userRole         VARCHAR2(1);
  BEGIN
    security.assertUserIdExists(p_UserID);
    assertNestExists(p_NestID);
    AssertUserInNestAlready(p_UserID, p_NestID);
    BEGIN
            SELECT 'Y'
              INTO v_userRole
              FROM invitation_table
             WHERE user_id = p_RequestingUser
               AND group_id = p_NestID
               AND (local_role = 1
                OR local_role = 2
                OR local_role = 0);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_userRole := 'N';
    END;
     
     BEGIN
      SELECT 'Y'
        INTO v_AlreadyHasInvite
        FROM invitation_table
       WHERE user_id = p_UserID
         AND group_id = p_NestID;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_AlreadyHasInvite := 'N';
    END;
     
    SELECT private
      INTO v_NestIsPrivate
      FROM message_group
     WHERE group_id = p_NestID;
    
    IF v_NestIsPrivate = 'Y' THEN
      SELECT COUNT(*)
        INTO v_PrivateCount
        FROM message_group
        JOIN invitation_table
       USING (group_id)
       WHERE group_id = p_NestID
         AND local_role = 3;
      
      IF v_PrivateCount < 2 THEN
        INSERT INTO invitation_table
        (user_id, group_id, is_invited, local_role, invite_status)
        VALUES
        (p_UserID, p_NestID, 'Y', p_LocalRole, 'Y');
        
        COMMIT;
      END IF;
    ELSE
          IF v_userRole = 'Y' THEN
              IF v_AlreadyHasInvite = 'Y' THEN
                UPDATE invitation_table 
                   SET invite_status = 'P',
                       is_invited    = 'Y'
                 WHERE user_id = p_UserID 
                   AND group_id = p_NestID;
              ELSE
                INSERT INTO invitation_table
                (user_id, group_id, is_invited, local_role, invite_status)
                VALUES
                (p_UserID, p_NestID, 'Y', p_LocalRole, 'P');
              END IF;
          END IF;
      COMMIT;
    END IF;
  END AddToNest;
  
  FUNCTION GetNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR
  AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserID);
    
    OPEN c_Data FOR
        SELECT group_id, group_name, css_class, is_activity_new
          FROM (SELECT group_id, GetNestName(p_UserID, group_id) group_name, 
          (CASE WHEN private = 'Y' OR is_muted = 'N' THEN 0 ELSE 1 END) ordercol, 
          (CASE WHEN private='Y' THEN 'fa-user' ELSE 'fa-users' END) css_class,
          (CASE WHEN is_activity_new = 'Y' AND is_muted = 'N' THEN 'new' ELSE ' ' END) is_activity_new          
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE user_id = p_UserID
                 AND visible = 'Y'
                 AND invite_status = 'Y'
                 AND ((private = 'Y' AND local_role = 3)
                  OR private = 'N')
               ORDER BY ordercol, last_activity DESC, lower(group_name) asc);
    RETURN c_Data;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsNotInAGroup, 'You ['||p_UserID||'] are not in any groups.');
  END GetNestsForUser;
  
  FUNCTION GetGroupNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR
  AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserID);
    
    OPEN c_Data FOR
        SELECT group_id, group_name, is_activity_new, '' as group_icon_url, 'fa-users' AS css_class, (CASE WHEN is_muted = 'Y' THEN ' muted' ELSE '' END) AS group_css_class
          FROM (SELECT group_id, GetNestName(p_UserID, group_id) group_name,
          (CASE WHEN is_activity_new = 'Y' AND is_muted = 'N' THEN 'new' ELSE ' ' END) is_activity_new,
          (CASE WHEN is_muted = 'N' THEN 0 ELSE 1 END) ordercol,
          is_muted
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE user_id = p_UserID
                 AND visible = 'Y'
                 AND private = 'N'
                 AND invite_status = 'Y'
               ORDER BY ordercol, last_activity DESC, lower(group_name) asc);
    RETURN c_Data;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsNotInAGroup, 'You ['||p_UserID||'] are not in any groups.');
  END GetGroupNestsForUser;
  
  FUNCTION GetPrivateNestsForUser (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR
  AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserID);
    
    OPEN c_Data FOR
        SELECT group_id, group_name, user_settings.GetUserIcon(security.get_user_id(group_name)) group_icon_url, 'fa-user' css_class, is_activity_new, (CASE WHEN is_muted = 'Y' THEN ' muted' ELSE '' END) group_css_class
          FROM (SELECT group_id, GetNestName(p_UserID, group_id) group_name,
          (CASE WHEN is_activity_new = 'Y' AND is_muted = 'N' THEN 'new' ELSE ' ' END) is_activity_new,
          is_muted,
          (CASE WHEN is_muted = 'N' THEN 0 ELSE 1 END) ordercol
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE user_id = p_UserID
                 AND visible = 'Y'
                 AND private = 'Y' AND local_role = 3
               ORDER BY ordercol, last_activity DESC, lower(group_name) asc);
    RETURN c_Data;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsNotInAGroup, 'You ['||p_UserID||'] are not in any groups.');
  END GetPrivateNestsForUser;
  
  FUNCTION GetNestsWithNotifications (
    p_UserID definitions.t_UserId
  ) RETURN SYS_REFCURSOR
  AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserID);
    
     OPEN c_Data FOR
        SELECT group_id, group_name, '' as group_icon_url, css_class, is_activity_new, ' ' group_css_class
          FROM (SELECT group_id, GetNestName(p_UserID, group_id) group_name, 
          (CASE WHEN private = 'Y' OR is_muted = 'N' THEN 0 ELSE 1 END) ordercol, 
          (CASE WHEN private='Y' THEN 'fa-user' ELSE 'fa-users' END) css_class,
          (CASE WHEN is_activity_new = 'Y' AND is_muted = 'N' THEN 'new' ELSE ' ' END) is_activity_new          
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE user_id = p_UserID
                 AND is_muted = 'N'
                 AND visible = 'Y'
                 AND invite_status = 'Y'
                 AND (is_activity_new = 'Y'
                  OR last_checked = null)
                 AND ((private = 'Y' AND local_role = 3)
                  OR private = 'N')
               ORDER BY ordercol, last_activity DESC, lower(group_name) asc);
    RETURN c_Data;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsNotInAGroup, 'You ['||p_UserID||'] are not in any groups.');
  END GetNestsWithNotifications;
  
  FUNCTION GetNestMembers (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN SYS_REFCURSOR
  AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserID);
    assertNestExists(p_NestID);
    messaging.assertUserInGroup(p_UserID, p_NestID);
    
    OPEN c_Data FOR
        SELECT user_id,
               user_name,
               (CASE WHEN local_role = 1 THEN 'Nest Creator' WHEN local_role = 2 THEN 'Admin' ELSE ' ' END) role_string,
               (CASE WHEN local_role = 1 THEN 'active' WHEN local_role = 2 THEN 'active' ELSE ' ' END) css_class,
               group_name,
               user_settings.GetUserIcon(user_id) as user_icon_url,
               local_role
          FROM user_information
          JOIN invitation_table
         USING (user_id)
          JOIN message_group
         USING (group_id)
         WHERE group_id = p_NestID
           AND ((group_id = -1) OR (group_id != -1 AND local_role != 0))
           AND invite_status = 'Y'
           AND banned = 'N'
         ORDER BY local_role asc, lower(user_name);
    RETURN c_Data;
  END GetNestMembers;
  
  FUNCTION GetNestName (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Name VARCHAR2(200);
  BEGIN
    security.assertUserIdExists(p_UserID);
   assertNestExists(p_NestID);
    messaging.assertUserInGroup(p_UserID, p_NestID);
  
    SELECT CASE WHEN private = 'Y' THEN (
                    SELECT user_name
                      FROM user_information
                      JOIN invitation_table
                     USING (user_id)
                      JOIN message_group
                     USING (group_id)
                     WHERE user_id != p_UserID
                       AND group_id = p_NestID
                       AND local_role = 3
                       AND rownum=1)
                ELSE (SELECT group_name
                        FROM message_group
                       WHERE group_id = p_NestID) END group_name
      INTO v_Name
      FROM message_group
     WHERE group_id = p_NestID;
     
    RETURN v_Name;
  END;
  
    FUNCTION GetUserInvites (
        p_UserID definitions.t_UserId
    ) RETURN SYS_REFCURSOR
      AS
        c_Data SYS_REFCURSOR;
      BEGIN
        security.assertUserIdExists(p_UserID);
        
        OPEN c_Data FOR
            SELECT group_id, group_name
              FROM (SELECT group_id, GetNestName(p_UserID, group_id) group_name         
                    FROM invitation_table
                   WHERE user_id = p_UserID
                     AND invite_status = 'P'
                   ORDER BY lower(group_name) asc);
        RETURN c_Data;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_APPLICATION_ERROR(definitions.k_ErrorUserHasNoInvites, 'You ['||p_UserID||'] do  not have any invites.');
  END GetUserInvites;
  
  PROCEDURE AcceptGroupInvitation (
    p_UserID   definitions.t_UserId,
    p_NestID   definitions.t_GroupId,
    p_Decision VARCHAR2
  ) AS
  BEGIN
    UPDATE invitation_table SET invite_status = CASE  
                                                    WHEN p_Decision = 'Y'  THEN 'Y'
                                                    WHEN p_Decision = 'N'  THEN 'N'
                                                    ELSE 'P'
                                                END
     WHERE p_UserID = user_id AND p_NestID = group_id;
    COMMIT;
  END AcceptGroupInvitation;
  
  PROCEDURE RemoveFromNest (
    p_RemovedUserID definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_RequestingUser definitions.t_UserId
  ) AS
      v_userRole VARCHAR(1);
      v_userIsOwner VARCHAR(1);
  BEGIN
    security.assertUserIdExists(p_RemovedUserID);
    assertNestExists(p_NestID);
    
    BEGIN
            SELECT 'Y'
              INTO v_userRole
              FROM invitation_table
             WHERE user_id = p_RequestingUser
               AND group_id = p_NestID
               AND local_role IN(0, 1, 2);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_userRole := 'N';
    END;

    BEGIN
            SELECT 'Y'
              INTO v_userIsOwner
              FROM message_group
             WHERE created_by = p_RemovedUserID
               AND group_id = p_NestID;
             
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_userIsOwner := 'N';
    END;
    IF(v_userIsOwner = 'N') THEN
        IF(v_userRole = 'Y') THEN
            BEGIN
                UPDATE invitation_table
                   SET is_invited = 'N', 
                       invite_status = 'N',
                       local_role = 3
                 WHERE user_id = p_RemovedUserID
                   AND group_id = p_NestID
                   AND local_role NOT IN (0, 1);       
                COMMIT;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END IF;
    END IF;
  END;

  FUNCTION NestExists (
    p_NestID definitions.t_GroupId
  )
  RETURN VARCHAR2 AS
    v_Exists VARCHAR2(1) DEFAULT 'N';
  BEGIN
    BEGIN
      SELECT 'Y'
        INTO v_Exists
        FROM message_group
       WHERE group_id = p_NestID;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_Exists := 'N';
    END;
    
    RETURN v_Exists;
  END NestExists;

  PROCEDURE NotifyUser (
    p_UserID definitions.t_UserId 
    ) AS
    BEGIN
      UPDATE invitation_table
         SET is_activity_new = CASE WHEN ((SELECT last_activity 
                                             FROM message_group
                                            WHERE message_group.group_id = invitation_table.group_id) IS NOT NULL
                                              AND last_checked < (SELECT last_activity
                                                                    FROM message_group
                                                                   WHERE message_group.group_id = invitation_table.group_id))
                                      OR last_checked IS NULL
                                    THEN 'Y'
                                    ELSE 'N'
                               END
         WHERE user_id = p_UserID;
       COMMIT;    
  END;

  FUNCTION CreatePrivateNest (
    p_UserA definitions.t_UserId,
    p_UserB definitions.t_UserId
  ) RETURN NUMBER AS
    v_NewGroupId definitions.t_GroupId;
  BEGIN
    CreatePrivateNest(p_UserA, p_UserB);
    
    SELECT group_id
        INTO v_NewGroupId
        FROM (SELECT group_id, COUNT(*) AS hits
                FROM message_group
                JOIN invitation_table
               USING (group_id)
               WHERE private = 'Y'
                 AND user_id IN (p_UserA, p_UserB)
                 AND local_role = 3
               GROUP BY group_id
               ORDER BY hits DESC)
       WHERE rownum = 1
         AND hits = 2;
    
    RETURN v_NewGroupId;
  END CreatePrivateNest;
  
  FUNCTION HasNewMessages(
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  ) RETURN VARCHAR2 AS
    v_Activity DATE;
    v_Checked  DATE;
  BEGIN
    SELECT last_activity
      INTO v_Activity
      FROM message_group
     WHERE group_id = p_NestID;
     
    SELECT last_checked
      INTO v_Checked
      FROM invitation_table
     WHERE group_id = p_NestID
       AND user_id = p_UserID;
     
    IF v_Activity > v_Checked OR v_Checked IS NULL THEN
        RETURN 'Y';
    ELSE
        RETURN 'N';
    END IF;
  END HasNewMessages;

  FUNCTION GetUserRole (
    p_UserID definitions.t_UserId,
    p_NestID definitions.t_GroupId
  )
  RETURN NUMBER AS
    v_UserRoleID NUMBER;
  BEGIN
  
    SELECT local_role
      INTO v_UserRoleID
      FROM invitation_table
     WHERE group_id = p_NestID
       AND user_id = p_UserID;
       
    RETURN v_UserRoleID;
  END GetUserRole;

  PROCEDURE LeaveNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserId
  )  AS
      v_userRole VARCHAR(1);
  BEGIN
    
    BEGIN
            SELECT 'Y'
              INTO v_userRole
              FROM invitation_table
             WHERE user_id = p_UserID
               AND group_id = p_NestID
               AND local_role IN(2, 3);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_userRole := 'N';
    END;

    IF(v_userRole = 'Y') THEN
        BEGIN
            UPDATE invitation_table
               SET is_invited = 'N', 
                   invite_status = 'N',
                   local_role = 3
             WHERE user_id = p_UserID
               AND group_id = p_NestID;      
            COMMIT;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
        END;
    END IF;
  END LeaveNest;

  FUNCTION GetMemberCounts(
    p_NestID definitions.t_GroupId
  ) RETURN NUMBER AS
  v_MemberCounts NUMBER;
  BEGIN
  
    SELECT COUNT(user_id)
      INTO v_MemberCounts
      FROM invitation_table
     WHERE group_id = p_NestID
       AND invite_status = 'Y';
    RETURN v_MemberCounts;
    
  END GetMemberCounts;

  PROCEDURE DeleteGroupNest (
    p_NestID definitions.t_GroupId,
    p_UserID definitions.t_UserID
  ) AS
    v_userRole VARCHAR2(1);
  BEGIN
    BEGIN
           SELECT 'Y'
             INTO v_userRole
             FROM invitation_table
            WHERE user_id = p_UserID
              AND group_id = p_NestID
              AND local_role IN (0, 1);
         EXCEPTION
             WHEN NO_DATA_FOUND THEN
                 v_userRole := 'N';
        
    END;
        IF(v_userRole = 'Y') THEN
            BEGIN
                UPDATE invitation_table
                   SET is_invited = 'N', 
                       invite_status = 'N'
                 WHERE group_id = p_NestID;      
                COMMIT;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
            BEGIN
                UPDATE message_group
                   SET visible = 'N'
                 WHERE group_id = p_NestID
                   AND created_by = p_UserID;
                COMMIT;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
            BEGIN
                UPDATE user_information
                   SET nests_created = (SELECT COUNT(*)
                                          FROM message_group
                                         WHERE created_by = p_UserID
                                           AND private = 'N'
                                           AND visible = 'Y')
                 WHERE user_id = p_UserID;
                COMMIT;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END IF;
    END DeleteGroupNest;

  FUNCTION IsNestPrivate (
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Private VARCHAR2(1) DEFAULT 'N';
  BEGIN
    assertNestExists(p_NestID);
    
    SELECT private
      INTO v_Private
      FROM message_group
     WHERE group_id = p_NestID;
    
    RETURN v_Private;
  END IsNestPrivate;

  PROCEDURE GrantLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  ) AS
    v_GrantedUser VARCHAR(1);
    v_IsOwner VARCHAR(1);
  BEGIN
    BEGIN
        SELECT 'Y'
          INTO v_GrantedUser
          FROM invitation_table
         WHERE user_id = p_LocalAdmin
           AND group_id = p_NestID
           AND local_role NOT IN (0,1,2);
    END;
    BEGIN
        SELECT 'Y'
          INTO v_IsOwner
          FROM invitation_table
         WHERE user_id = p_NestCreator
           AND group_id = p_NestID
           AND local_role IN (0,1);
    END;
    BEGIN
        IF(v_GrantedUser = 'Y') THEN
            IF(v_IsOwner = 'Y') THEN
                BEGIN
                    UPDATE invitation_table
                       SET local_role = 2
                     WHERE user_id = p_LocalAdmin
                       AND group_id = p_NestID
                       AND local_role NOT IN (0,1,2);
                    COMMIT;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            NULL;
                END;
            END IF;
        END IF;
    END;
  END GrantLocalAdmin;

  PROCEDURE RevokeLocalAdmin(
    p_NestCreator definitions.t_UserId,
    p_NestID definitions.t_GroupId,
    p_LocalAdmin definitions.t_UserId
  ) AS
  BEGIN    
    BEGIN
        UPDATE invitation_table
           SET local_role = 3
         WHERE user_id = p_LocalAdmin
           AND group_id = p_NestID
           AND local_role = 2;
        COMMIT;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
    END;
  END RevokeLocalAdmin;

  PROCEDURE ToggleNestMute (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) AS
  BEGIN
    messaging.assertUserInGroup(p_UserId, p_NestId);
    
    UPDATE invitation_table
       SET is_muted = CASE WHEN is_muted = 'Y'
                           THEN 'N'
                           ELSE 'Y'
                      END
     WHERE user_id = p_UserId
       AND group_id = p_NestId;
    
  END ToggleNestMute;
  
  FUNCTION UserHasNestMuted (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Muted VARCHAR2(1) DEFAULT 'N';
  BEGIN
    messaging.assertUserInGroup(p_UserId, p_NestId);
    
    SELECT is_muted
      INTO v_Muted
      FROM invitation_table
     WHERE user_id = p_UserId
       AND group_id = p_NestId;
       
    RETURN v_Muted;
  END;
  
  PROCEDURE ToggleNestLock (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) AS
    v_UserRole definitions.t_UserRole;
    v_CreatorId definitions.t_UserId;
    v_NestName definitions.t_GroupName;
    v_IsLocked VARCHAR2(1) DEFAULT 'N';
  BEGIN
    SELECT user_role
      INTO v_UserRole
      FROM user_information
     WHERE user_id = p_UserId;
     
     IF v_UserRole = 'admin' THEN
       UPDATE message_group
          SET locked_by_admin = CASE WHEN locked_by_admin = 'Y'
                                     THEN 'N'
                                     ELSE 'Y'
                                END
        WHERE group_id = p_NestId;
        
        COMMIT;
        
        SELECT CREATED_BY
          INTO v_CreatorId
          FROM message_group
         WHERE group_id = p_NestId;
        
        SELECT group_name
          INTO v_NestName
          FROM message_group
         WHERE group_id = p_NestId;
        
        SELECT locked_by_admin
          INTO v_IsLocked
          FROM message_group
         WHERE group_id = p_NestId;
        
        notification_api.SendNotification(
           p_UserId => v_CreatorId,
           p_NotifBody => 'Your Nest, "'||v_NestName||'", has been '||(CASE WHEN v_IsLocked = 'Y' THEN 'locked' ELSE 'unlocked' END)||' by a system administrator.'
        );
     END IF;
  END ToggleNestLock;

  FUNCTION NestIsLocked (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Locked VARCHAR2(1) DEFAULT 'N';
  BEGIN
    
    SELECT locked_by_admin
      INTO v_Locked
      FROM message_group
     WHERE group_id = p_NestId;
    
    RETURN v_Locked;
  END NestIsLocked;

  FUNCTION IsUserInvited (
      p_InvitedUserID definitions.t_UserId,
      p_NestID definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_IsInvited VARCHAR2(1) DEFAULT 'N';
  BEGIN
    BEGIN
        SELECT 'Y'
          INTO v_IsInvited
          FROM invitation_table
         WHERE invite_status = 'P'
           AND group_id = p_NestID
           AND user_id = p_InvitedUserID;
        EXCEPTION WHEN NO_DATA_FOUND THEN
            v_IsInvited := 'N';
    END;
    
    IF v_IsInvited = 'Y' THEN
      RAISE_APPLICATION_ERROR(definitions.k_ErrorUserIsAlreadyInvited, 'User is already invited.');
    END IF;    
    RETURN v_IsInvited;
  END IsUserInvited;

  FUNCTION UserIsKicked (
    p_UserId definitions.t_UserId,
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Kicked VARCHAR2(1);
  BEGIN
    SELECT (CASE WHEN INVITE_STATUS = 'N' THEN 'Y' ELSE 'N' END)
      INTO v_Kicked
      FROM invitation_table
     WHERE group_id = p_NestId
       AND user_id = p_UserId;
       
    RETURN v_Kicked;
  END UserIsKicked;

  FUNCTION NestIsVisible (
    p_NestId definitions.t_GroupId
  ) RETURN VARCHAR2 AS
    v_Visible VARCHAR2(1) DEFAULT 'N';
  BEGIN
    
    SELECT visible
      INTO v_Visible
      FROM message_group
     WHERE group_id = p_NestId;
    
    RETURN v_Visible;
  END NestIsVisible;

END NESTS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NESTS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body NOTIFICATION_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."NOTIFICATION_API" AS

  PROCEDURE SendNotification (
        p_UserId definitions.t_UserId,
        p_NotifBody definitions.t_NotifBody
    ) AS
  BEGIN
    security.assertUserIdExists(p_UserId);
    
    INSERT INTO notifications
    (notif_id, user_id, notif_body)
    VALUES
    (SEQ_NOTIF_ID.NEXTVAL, p_UserId, p_NotifBody);
    
    COMMIT;
  END SendNotification;
  
  FUNCTION GetNotifications (
    p_UserId definitions.t_UserId
  ) RETURN SYS_REFCURSOR AS
    c_Data SYS_REFCURSOR;
  BEGIN
    security.assertUserIdExists(p_UserId);
    
    OPEN c_Data FOR
        SELECT notif_id, notif_body, time_sent, (CASE WHEN time_sent > (SELECT LASTCHECKEDNOTIFS
                                                                          FROM user_information
                                                                         WHERE user_id = p_UserId)
                                                      THEN 'new-notifs'
                                                      ELSE ''
                                                 END) css_class
          FROM notifications
         WHERE user_id = p_UserId
         ORDER BY time_sent DESC;
  
    UPDATE user_information
       SET LASTCHECKEDNOTIFS = SYSDATE
     WHERE user_id = p_UserID;
    
    COMMIT;
  
    RETURN c_Data;
  END;

  FUNCTION UserHasNewNotifications (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2 AS
    v_Response VARCHAR2(1) DEFAULT 'N';
    v_NewNotifs PLS_INTEGER;
  BEGIN
    security.assertUserIdExists(p_UserId);
    
    SELECT count(*)
      INTO v_NewNotifs
      FROM notifications
     WHERE user_id = p_UserId
       AND time_sent > (SELECT lastcheckednotifs
                          FROM user_information
                         WHERE user_id = p_UserId);
    
    v_Response := CASE WHEN v_NewNotifs > 0 THEN 'Y' ELSE 'N' END;
    
    RETURN v_Response;
  END;
END NOTIFICATION_API;

/

  GRANT EXECUTE ON "CS414_TEAM2"."NOTIFICATION_API" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body SEARCHING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."SEARCHING" AS
  /* Searches for user(s) with the exact or similar name */
  FUNCTION search_username(p_username definitions.t_Username)
    RETURN SYS_REFCURSOR 
    AS
     sys_var SYS_REFCURSOR;
  BEGIN
    IF p_username IS NOT NULL THEN 
        OPEN sys_var FOR
            SELECT user_name, user_id, user_settings.GetUserIcon(user_id) as user_icon_url
              FROM user_information
             WHERE LOWER(user_name) LIKE LOWER(p_username) || '%';
    ELSE
        RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorUserDoesNotExist, 'User does not exist');       
      END IF;  
    RETURN sys_var;
  END;
  
  FUNCTION invite_username(p_username definitions.t_Username, p_NestId definitions.t_GroupId)
    RETURN SYS_REFCURSOR 
    AS
     sys_var SYS_REFCURSOR;
  BEGIN
    IF p_username IS NOT NULL THEN 
       OPEN sys_var FOR
            SELECT user_name, user_id, user_settings.GetUserIcon(user_id) as user_icon_url
              FROM user_information
             WHERE LOWER(user_name) LIKE LOWER(p_username) || '%'
               AND user_id NOT IN (SELECT user_id FROM invitation_table WHERE group_id = p_NestId AND INVITE_STATUS != 'N');
    ELSE
        RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorUserDoesNotExist, 'User does not exist');       
      END IF;  
    RETURN sys_var;
  END;
  
  FUNCTION SearchForNest(
        p_NestName definitions.t_GroupName DEFAULT '',
        p_NestId definitions.t_GroupId     DEFAULT '')
    RETURN SYS_REFCURSOR
    AS
     sys_var SYS_REFCURSOR;
    BEGIN
        IF p_NestName IS NULL THEN
            IF p_NestId IS NULL THEN
                RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorNoGroupInformation, 'No group name or id given.');
            ELSE
                OPEN sys_var FOR
                 SELECT group_name, group_id, (CASE WHEN visible = 'Y' THEN 'Visible' ELSE 'Deleted' END) as visible
                   FROM message_group
                  WHERE LOWER(group_id) LIKE LOWER(p_NestId) || '%'
               ORDER BY group_id ASC;
            END IF;
        ELSE    
            OPEN sys_var FOR
                 SELECT group_name, group_id, (CASE WHEN visible = 'Y' THEN 'Visible' ELSE 'Deleted' END) as visible
                   FROM message_group
                  WHERE LOWER(group_name) LIKE LOWER(p_NestName) || '%'
               ORDER BY group_id ASC;
        END IF;
    RETURN sys_var;
  END SearchForNest;

  FUNCTION IsInvited(
        p_username definitions.t_Username,
        p_NestId definitions.t_GroupId)
    RETURN VARCHAR2 AS
    v_InviteStatus VARCHAR2(1) DEFAULT 'N';
  BEGIN
    SELECT 'P'
      INTO v_InviteStatus
      FROM invitation_table
      JOIN user_information
     USING (user_id)
     WHERE invite_status = 'P'
       AND group_id = p_NestId
       AND user_name = p_username;    
    RETURN v_InviteStatus;
  END IsInvited;

END searching;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SEARCHING" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body SECURITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."SECURITY" AS
    /* Check that a user exists by id. */
    PROCEDURE assertUserIdExists (
        p_id definitions.t_UserId)
    AS
        v_Exists VARCHAR2(1) DEFAULT 'N';
    BEGIN
        SELECT 'Y'
          INTO v_Exists
          FROM user_information
         WHERE user_id = p_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserDoesNotExist, 'User ['||p_id||'] does not exist.');
    END;
    
    PROCEDURE AssertUserIsntBanned (
        p_username definitions.t_Username)
    AS
        v_Banned VARCHAR2(1) DEFAULT 'N';
    BEGIN
        SELECT 'Y'
          INTO v_Banned
          FROM user_information
         WHERE user_name = p_username
           AND banned != 'Y';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserHasBeenBanned, 'User ['||p_username||'] has been banned.');
    END;
    
    /* Check that a user exists by name. */
    PROCEDURE assertUsernameExists (
        p_username definitions.t_Username)
    AS
        v_Exists VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_Exists
              FROM user_information
             WHERE user_name = p_username;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Exists := 'N';
        END;
        
        IF v_Exists = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserDoesNotExist, 'User ['||p_username||'] does not exist.');
        END IF;
    END;
        
    /* Check that username is available. */
    PROCEDURE assertUsernameFree(
        p_username definitions.t_Username)
    AS
        v_exists VARCHAR2(1);
    BEGIN
        BEGIN
            SELECT 'y'
              INTO v_exists
              FROM user_information
             WHERE user_name = p_username;
            IF v_exists = 'y' THEN
                RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorUserExistsAlready, 'User already exists.');
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_exists := 'n';
        END;
    END;
      
    /* Check the email is valid and not in use. */
    PROCEDURE assertEmailFree(
        p_email definitions.t_Email)
    AS
        v_exists VARCHAR2(1);
    BEGIN
        IF REGEXP_LIKE(p_email, definitions.k_EmailRegex) THEN
            BEGIN
                SELECT 'y'
                  INTO v_exists
                  FROM user_information
                 WHERE user_email = p_email;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_exists := 'n';
            END;
            IF v_exists = 'y' THEN
                RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorEmailExistsAlready, 'Email already in use.');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorInvalidEmail, 'Email address is not valid.');
        END IF;
    END;
    
    PROCEDURE assertEmailExists (
        p_email definitions.t_Email)
    AS
        v_Exists VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_Exists
              FROM user_information
             WHERE user_email = p_email;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Exists := 'N';
        END;
        
        IF v_Exists = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorEmailDoesNotExist, 'User email ['||p_email||'] does not exist.');
        END IF;
    END;
    
    /* Validate that a passcode is correct and that a passcode exists. */
    PROCEDURE assertPasscodeIsValid (
        p_passcode definitions.t_Passcode,
        p_username definitions.t_Username)
    AS
        v_Valid VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_Valid
              FROM user_information
             WHERE user_passcode = p_passcode
               AND user_name = p_username;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Valid := 'N';
                RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPasscode, 'User has no passcode assigned.');
        END;
        
        IF v_Valid = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPasscode, 'Passcode is not correct.');
        END IF;
    END;
    
    /* Check that a user is allowed to login by login attempts. */
    PROCEDURE assertUserLoginAttempts (
        p_username definitions.t_Username)
    AS
        v_LoginAttempts NUMBER DEFAULT NULL;
        v_RowsAffected  PLS_INTEGER;
    BEGIN
        SELECT ATTEMPTNUMBER
          INTO v_LoginAttempts
          FROM user_information
         WHERE user_name = p_username;
         IF v_LoginAttempts > 5 THEN
            UPDATE user_information
               SET attemptnumber = 0
             WHERE user_name = p_username
               AND ( extract( minute from systimestamp - lastattempt) >= 15 
                     OR extract( hour from systimestamp - lastattempt) >   0 
                     OR extract(  day from systimestamp - lastattempt) >   0)
               AND ATTEMPTNUMBER >= 5;
            v_RowsAffected := SQL%ROWCOUNT;
            COMMIT;
            IF v_RowsAffected = 0 THEN
                RAISE_APPLICATION_ERROR(definitions.k_ErrorUserDoesNotExist, 'User is not allowed to login with more than 5 attempts please wait 15 minutes.');
            END IF;
        END IF;
    END;
    
    PROCEDURE AssertEmailIsConfirmed (
        p_username definitions.t_Username)
    AS
        v_EmailConfirmed VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_EmailConfirmed
              FROM user_information
             WHERE user_name = p_username
               AND email_confirmation = 'Y';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_EmailConfirmed := 'N';
        END;
        
        IF v_EmailConfirmed = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorEmailNotConfirmed, 'User has not confirmed their email.');
        END IF;
    END;
    
    /* Add an user to the user_information table */
    PROCEDURE add_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password,
        p_email    definitions.t_Email)
    AS
    BEGIN
        assertUsernameFree(TRIM(p_username));
        assertEmailFree(TRIM(p_email));
        
        IF REGEXP_LIKE(p_username, definitions.k_UserNameRegex) THEN
            INSERT INTO user_information (
                user_id,
                user_name,
                user_password,
                user_email,
                user_icon_id
            )
            VALUES (
                user_id.NEXTVAL,
                TRIM(p_username),
                create_pass_hash(TRIM(p_username), p_password),
                TRIM(p_email),
                CAST(DBMS_RANDOM.VALUE(0, (SELECT COUNT(*) FROM USER_ICONS WHERE ICON_ID >= 0) - 1) AS INTEGER)
            );
            
            COMMIT;
            
            update_passcode(TRIM(p_email), p_username);
        ELSE
            RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUsername, 'Invalid username. Usernames can only contain alphanumeric characters and underscores, and be between 4-25 characters long.');
        END IF;
    END;
    
    /* Changes current password with new passwords */
    PROCEDURE change_password (
        p_username     definitions.t_Username,
        p_new_password definitions.t_Password,
        p_old_password definitions.t_Password DEFAULT '',
        p_passcode     definitions.t_Passcode DEFAULT '')
    AS
    BEGIN
        assertUsernameExists(p_username);
        IF p_old_password IS NULL THEN
            IF p_passcode IS NULL THEN
                RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorNoPassNoCode, 'No password or passcode given.');
            ELSE
                assertPasscodeIsValid(p_passcode, p_username);
                BEGIN
                    UPDATE user_information
                       SET user_password = create_pass_hash(p_username, p_new_password)
                     WHERE user_name = p_username
                       AND user_passcode = p_passcode;
                       
                       COMMIT;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPasscode, 'Invalid username/passcode.');
                    WHEN OTHERS THEN
                        RAISE;
                END;
            END IF;
        ELSE    
            BEGIN
                UPDATE user_information
                   SET user_password = create_pass_hash(p_username, p_new_password)
                 WHERE user_name = p_username
                   AND user_password = create_pass_hash(p_username, p_old_password);
                   
                   COMMIT;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPass, 'Invalid username/password.');
                WHEN OTHERS THEN
                    RAISE;
            END;
        END IF;
        COMMIT;
    END;
    
    /* Gets the hash for the password column. */
    FUNCTION create_pass_hash (
        p_identifier VARCHAR2,
        p_password   VARCHAR2)
    RETURN VARCHAR2 AS
        l_salt VARCHAR2(30) := 'masonwasnothere_';
    BEGIN
        RETURN DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_identifier || l_salt || p_password),DBMS_CRYPTO.HASH_SH1);
    END;
    
    /* Returns the temporary passcode value in the database. */
    FUNCTION return_passcode (
        p_email     definitions.t_Email,
        p_username definitions.t_Username)
    RETURN VARCHAR2
    AS
        v_passcode VARCHAR2(8);
    BEGIN
        assertEmailExists(p_email);
        assertUsernameExists(p_username);
        SELECT user_passcode
          INTO v_passcode
          FROM user_information
         WHERE user_email = p_email
           AND user_name  = p_username;
        RETURN v_passcode;
    END return_passcode;

    /* Updates the user_information table with new user_passcode. */
    PROCEDURE update_passcode (
        p_email    definitions.t_Email,
        p_username definitions.t_Username) 
    AS
        v_randomString VARCHAR2(8);
    BEGIN
        assertEmailExists(p_email);
        assertUsernameExists(p_username);
        v_randomString := DBMS_RANDOM.STRING('X', 8);
        UPDATE user_information
           SET user_passcode = v_randomString
         WHERE user_email = p_email 
           AND user_name  = p_username;
         COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPass, 'Invalid username or email address.');
    END update_passcode;
    
    PROCEDURE ConfirmEmailAddress(
        p_email    definitions.t_Email,
        p_passcode definitions.t_Passcode)
    AS
        v_username definitions.t_Username;
    BEGIN
        BEGIN
            SELECT user_name
              INTO v_username
              FROM user_information
             WHERE user_email = p_email;
        END;
        assertEmailExists(p_email);
        assertPasscodeIsValid(p_passcode, v_username);
        
        UPDATE user_information
           SET email_confirmation = 'Y'
         WHERE user_email = p_email 
           AND user_passcode = p_passcode;
        COMMIT;
        
        -- Add new users to Pigeon's Nest
        INSERT INTO invitation_table
        (user_id, group_id, is_invited, local_role, invite_status)
        VALUES
        (get_user_id(v_username), 242, 'Y', 3, 'Y');
        COMMIT;
    END ConfirmEmailAddress;

    /* Gets the hash for the current login token. */
    FUNCTION create_token_hash (
        p_username definitions.t_Username,
        p_lastlog  TIMESTAMP)
    RETURN VARCHAR2
    AS
        l_salt VARCHAR2(26) := 'ivegotabadfeelingaboutthis';
    BEGIN
        RETURN DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_username || l_salt || to_char(p_lastlog, 'yyyyddmmhh24missff')),DBMS_CRYPTO.HASH_SH1);
    END;
      
    FUNCTION IsActive (
        p_username definitions.t_Username
    )
    RETURN VARCHAR2
    AS
        v_IsActive VARCHAR2(1);
    BEGIN
        BEGIN
            SELECT 'N'
              INTO v_IsActive
              FROM user_information
             WHERE user_name = p_username
               AND (islogin = 'Y' OR currenttoken != '')
               AND ( extract( minute from systimestamp - lastonline) >= 15 
                    OR extract( hour from systimestamp - lastonline) >   0 
                    OR extract(  day from systimestamp - lastonline) >   0);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_IsActive := 'Y';
        END;
        
        IF v_IsActive = 'N' THEN
            UPDATE user_information 
               SET islogin       = 'N', 
                   currenttoken  = '', 
                   attemptnumber = 0 
             WHERE user_name = p_username;
             
             COMMIT;
        END IF;
        
        RETURN v_IsActive;
    END;
      
    /* Attempts to log in a user with given information. */
    PROCEDURE login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N')
    AS
    BEGIN
        assertUsernameExists(p_username);
        assertUserLoginAttempts(p_username);
        AssertEmailIsConfirmed (p_username);
        AssertUserIsntBanned   (p_username);
        BEGIN
            IF p_EmailJustConfirmed = 'Y' THEN
                UPDATE user_information
                   SET islogin = 'Y',
                       attemptnumber = 0,
                       lastattempt = SYSTIMESTAMP,
                       lastlogin = SYSTIMESTAMP,
                       lastonline = SYSTIMESTAMP,
                       currenttoken = create_token_hash(p_username, SYSTIMESTAMP),
                       user_passcode = ''
                 WHERE user_name = p_username;
                   
               COMMIT;
            ELSE
                IF p_password = '' THEN
                    IF p_token = '' THEN
                        RAISE_APPLICATION_ERROR(DEFINITIONS.k_ErrorNoPassNoToken, 'No login credentials given.');
                    ELSE
                        IF valid_user(p_username => p_username, p_token => p_token) = 'Y' THEN
                            UPDATE user_information
                               SET islogin = 'Y',
                                   attemptnumber = 0,
                                   lastattempt = SYSTIMESTAMP,
                                   lastlogin = SYSTIMESTAMP,
                                   lastonline = SYSTIMESTAMP,
                                   user_passcode = ''
                             WHERE user_name = p_username;
                               
                               COMMIT;
                        ELSE
                            UPDATE user_information
                               SET attemptnumber = attemptnumber + 1,
                                   lastattempt = SYSTIMESTAMP,
                                   user_passcode = ''
                             WHERE user_name = p_username;
                             
                             COMMIT;
                             
                             RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPass, 'Invalid username and password.');
                        END IF;
                    END IF;
                ELSE
                    IF valid_user(p_username => p_username, p_password => p_password) = 'Y' THEN
                        UPDATE user_information
                           SET islogin = 'Y',
                               attemptnumber = 0,
                               lastattempt = SYSTIMESTAMP,
                               lastlogin = SYSTIMESTAMP,
                               lastonline = SYSTIMESTAMP,
                               currenttoken = create_token_hash(p_username, SYSTIMESTAMP),
                               user_passcode = ''
                         WHERE user_name = p_username;
                           
                           COMMIT;
                    ELSE
                        UPDATE user_information
                           SET attemptnumber = attemptnumber + 1,
                               lastattempt = SYSTIMESTAMP
                         WHERE user_name = p_username;
                         
                         COMMIT;
                         
                         RAISE_APPLICATION_ERROR(definitions.k_ErrorInvalidUserPass, 'Invalid username and password.');
                    END IF;
                END IF;
            END IF;
            
            COMMIT;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR(definitions.k_ErrorAlreadyLoggedIn,'User is already logged in.');
            WHEN OTHERS THEN
                RAISE;
        END;
    END;
      
    /* Attempts to log in a user, returns login token. */
    FUNCTION login_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password  DEFAULT '',
        p_token    definitions.t_AuthToken DEFAULT '',
        p_EmailJustConfirmed VARCHAR2 DEFAULT 'N')
    RETURN VARCHAR2
    AS
        v_loggedin VARCHAR2(1);
        v_token    definitions.t_AuthToken := '';
    BEGIN
        login_user(p_username => p_username,
                   p_password => p_password,
                   p_token    => p_token,
                   p_EmailJustConfirmed => p_EmailJustConfirmed);
        
        SELECT islogin
          INTO v_loggedin
          FROM user_information
         WHERE user_name = p_username;
        
        IF v_loggedin = 'Y' THEN
            SELECT currenttoken
              INTO v_token
              FROM user_information
             WHERE user_name = p_username;
        END IF;
        
        RETURN v_token;
    END;
      
    /* Logs out a user. */
    PROCEDURE logout_user (
        p_username definitions.t_Username)
    AS
        v_userOnline VARCHAR2(1) DEFAULT 'N';
    BEGIN
        BEGIN
            SELECT 'Y'
              INTO v_userOnline
              FROM user_information
             WHERE user_name = p_username
               AND islogin = 'Y';
             
        UPDATE user_information
           SET islogin = 'N',
               currenttoken = '',
               lastonline = SYSTIMESTAMP
         WHERE user_name = p_username;
         
         COMMIT;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_userOnline := 'N';
        END;
    END;
      
    /* Checks if username and password matches */
    PROCEDURE valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password)
    AS
        v_exist  VARCHAR2(1);
    BEGIN
        SELECT 'y'
          INTO v_exist
          FROM user_information
         WHERE user_name = TRIM(p_username)
           AND user_password = create_pass_hash(TRIM(p_username), p_password);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_exist := 'n';
        WHEN OTHERS THEN 
            RAISE;
    END;
    
    /* Returns 'Y' if given token matches one on file. */
    FUNCTION valid_token(
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2
    AS
        v_Valid VARCHAR2(1) DEFAULT 'N';
    BEGIN
        assertUsernameExists(p_username);
        
        BEGIN
            SELECT 'Y'
              INTO v_Valid
              FROM user_information
             WHERE user_name = p_username
               AND currenttoken = p_token;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Valid := 'N';
        END;
        RETURN v_Valid;
    END;
    
    /* Returns validated username and password */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_password definitions.t_Password)
    RETURN VARCHAR2 AS
        v_exist  VARCHAR2(1) DEFAULT 'N';
    BEGIN
        SELECT 'Y'
          INTO v_exist
          FROM  user_information
         WHERE user_name = TRIM(p_username)
           AND user_password = create_pass_hash(TRIM(p_username), p_password);   
        RETURN v_exist;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_exist := 'N';
            RETURN v_exist;
        WHEN OTHERS THEN 
            RAISE;
    END;
    
    /* Returns whether given login token matches current token. */
    FUNCTION valid_user (
        p_username definitions.t_Username,
        p_token    definitions.t_AuthToken)
    RETURN VARCHAR2 AS
        v_correct  VARCHAR2(1) DEFAULT 'N';
    BEGIN
        SELECT 'Y'
          INTO v_correct
          FROM user_information
         WHERE user_name = TRIM(p_username)
           AND currenttoken = p_token;
        RETURN v_correct;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_correct := 'N';
            RETURN v_correct;
        WHEN OTHERS THEN 
            RAISE;
    END;    
    
  FUNCTION decrypt_message (
        p_message definitions.t_MessageText,
        p_key     definitions.t_NestCryptKey)
    RETURN VARCHAR2 AS
  BEGIN
    RETURN UTL_I18N.RAW_TO_CHAR (DBMS_CRYPTO.DECRYPT(src => p_message,
                                                     typ => definitions.k_EncryptionType,
                                                     key => p_Key),
                                 'AL32UTF8'); 
  END decrypt_message;

  FUNCTION encrypt_message (
        p_message VARCHAR2,
        p_key     definitions.t_NestCryptKey)
    RETURN RAW AS
  BEGIN
    RETURN DBMS_CRYPTO.ENCRYPT(src => UTL_I18N.STRING_TO_RAW (p_message, 'AL32UTF8'),
                               typ => definitions.k_EncryptionType,
                               key => p_Key);
  END encrypt_message;

  PROCEDURE EncryptFile (
    p_Destination IN OUT BLOB,
    p_Base64 CLOB,
    p_Key definitions.t_NestCryptKey)
  AS
  BEGIN
    DBMS_CRYPTO.ENCRYPT(dst => p_Destination,
                        src => p_Base64,
                        typ => definitions.k_EncryptionType,
                        key => p_Key);
  END EncryptFile;

  FUNCTION get_user_id (
        p_username definitions.t_Username)
    RETURN definitions.t_Userid AS
    v_ID definitions.t_UserId;
  BEGIN
    assertUsernameExists(p_username);
  
    SELECT user_id
      INTO v_ID
      FROM user_information
     WHERE user_name = p_username;
     
    RETURN v_ID;
  END get_user_id;
  
  PROCEDURE is_admin(
        p_username definitions.t_Username,
        p_user_id  definitions.t_UserID)
    AS
        v_Admin VARCHAR2(1) DEFAULT 'N';
    BEGIN
        assertUsernameExists(p_username);
        messaging.assertUsernameIDMatch (p_username,p_user_id);
        BEGIN
            SELECT 'Y'
              INTO v_Admin
              FROM user_information
             WHERE user_name = p_username
               AND user_id = p_user_id
               AND user_role = 'admin';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_Admin := 'N';
        IF v_Admin = 'N' THEN
            RAISE_APPLICATION_ERROR(definitions.k_ErrorUserNotAdmin, 'User ['||p_username||'] is not an admin.');
        END IF;
        END;
    END;
    
  PROCEDURE LogoutInactiveUsers AS
    BEGIN
        UPDATE user_information
           SET islogin       = 'N',
               currenttoken  = ''
         WHERE (islogin = 'Y' OR currenttoken != '')
           AND user_role != 'admin'
           AND ( extract( minute from systimestamp - lastonline) >= 15 
                OR extract( hour from systimestamp - lastonline) >   0 
                OR extract(  day from systimestamp - lastonline) >   0);
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END LogoutInactiveUsers;

  PROCEDURE LogUserActivity (
        p_UserId definitions.t_UserId
    ) AS
    BEGIN
        assertUserIdExists(p_UserId);
        
        UPDATE user_information
           SET lastonline = systimestamp
         WHERE user_id = p_UserId;
    END LogUserActivity;

  PROCEDURE DecryptFile (
        p_Destination IN OUT CLOB,
        p_EncryptedData BLOB,
        p_Key definitions.t_NestCryptKey) AS
  BEGIN
    DBMS_CRYPTO.DECRYPT(dst => p_Destination,
                        src => p_EncryptedData,
                        typ => definitions.k_EncryptionType,
                        key => p_Key);
  END DecryptFile;

END;

/

  GRANT EXECUTE ON "CS414_TEAM2"."SECURITY" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."STATISTICS" AS

    FUNCTION gather_statistics (
        p_statistic_type VARCHAR2 DEFAULT NULL,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL,
        p_group_id definitions.t_GroupId DEFAULT NULL,
        p_user_id definitions.t_UserId DEFAULT NULL)
    RETURN SYS_REFCURSOR AS
    BEGIN
        CASE
            WHEN p_statistic_type = 'all messages' 
                THEN RETURN message_count (p_start_date, p_end_date);
            WHEN p_statistic_type = 'most active group' 
                THEN RETURN most_active_group (p_start_date, p_end_date);
            WHEN p_statistic_type = 'most active user' 
                THEN RETURN most_active_user (p_start_date, p_end_date);
            WHEN p_statistic_type = 'group message count' 
                THEN nests.AssertNestExists(p_group_id); 
                    RETURN get_group_message_count (p_group_id, p_start_date, p_end_date);
            WHEN p_statistic_type = 'user message count' 
                THEN security.assertUserIdExists(p_user_id); 
                    RETURN get_user_message_count (p_user_id, p_start_date, p_end_date);
            ELSE RAISE_APPLICATION_ERROR(definitions.k_ErrorStatisticTypeUnassigned, 'Valid statistic type was not assigned.');
        END CASE;
    END gather_statistics;


    FUNCTION message_count (
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR AS
        sys_var SYS_REFCURSOR;
        v_start_date  DATE;
    BEGIN
        IF p_start_date IS NULL THEN 
            v_start_date := SYSDATE - 1;
        ELSE
            v_start_date := p_start_date;
        END IF;
       OPEN sys_var FOR 
            SELECT COUNT(*) cnt
            FROM message_text 
            WHERE ((p_end_date IS NOT NULL AND time_sent BETWEEN v_start_date AND p_end_date)
              OR (p_end_date IS NULL AND time_sent > v_start_date));
    RETURN sys_var;
    END message_count;
    
    
    FUNCTION most_active_group(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR AS
        sys_var SYS_REFCURSOR;
        v_start_date  DATE;
    BEGIN
        IF p_start_date IS NULL THEN 
            v_start_date := SYSDATE - 1;
        ELSE
            v_start_date := p_start_date;
        END IF;
        OPEN sys_var FOR 
           WITH group_totals 
           AS (SELECT group_id, COUNT(*) cnt, group_name 
           FROM message_text JOIN message_group 
           USING(group_id)
           WHERE ((p_end_date IS NOT NULL AND time_sent BETWEEN v_start_date AND p_end_date)
              OR (p_end_date IS NULL AND time_sent > v_start_date))
           GROUP BY group_name, group_id)
           SELECT group_name, group_id, cnt FROM group_totals WHERE cnt = (SELECT MAX(cnt) FROM group_totals);
    RETURN sys_var;
    END most_active_group;
    
    FUNCTION get_group_message_count(
        p_group_id definitions.t_GroupId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR AS
        sys_var SYS_REFCURSOR;
        v_start_date  DATE;
    BEGIN
        IF p_start_date IS NULL THEN 
            v_start_date := SYSDATE - 1;
        ELSE
            v_start_date := p_start_date;
        END IF;
        OPEN sys_var FOR 
            WITH group_totals AS
            (SELECT group_id, COUNT(*) cnt, group_name
            FROM message_text JOIN message_group 
            USING(group_id)
            WHERE p_group_id = group_id
            AND ((p_end_date IS NOT NULL AND time_sent BETWEEN v_start_date AND p_end_date)
              OR (p_end_date IS NULL AND time_sent > v_start_date))
            GROUP BY group_name, group_id)
            SELECT group_name, group_id, cnt FROM group_totals WHERE cnt = (SELECT MAX(cnt) FROM group_totals);
    RETURN sys_var;
    END get_group_message_count;
    
    FUNCTION most_active_user(
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
   RETURN SYS_REFCURSOR AS
        sys_var SYS_REFCURSOR;
        v_start_date  DATE;
    BEGIN
        IF p_start_date IS NULL THEN 
            v_start_date := SYSDATE - 1;
        ELSE
            v_start_date := p_start_date;
        END IF;
        OPEN sys_var FOR 
            WITH user_totals 
            AS (SELECT user_id, COUNT(*) cnt, user_name
            FROM message_text JOIN user_information
            USING(user_id)
            WHERE ((p_end_date IS NOT NULL AND time_sent BETWEEN v_start_date AND p_end_date)
              OR (p_end_date IS NULL AND time_sent > v_start_date))
          GROUP BY user_name, user_id)
           SELECT user_name, user_id, cnt FROM user_totals WHERE cnt = (SELECT MAX(cnt) FROM user_totals);
    RETURN sys_var;
    END most_active_user;
    
    FUNCTION get_user_message_count(
        p_user_id definitions.t_UserId,
        p_start_date DATE DEFAULT NULL,
        p_end_date DATE DEFAULT NULL)
    RETURN SYS_REFCURSOR AS
        sys_var SYS_REFCURSOR;
        v_start_date  DATE;
    BEGIN
        IF p_start_date IS NULL THEN 
            v_start_date := SYSDATE - 1;
        ELSE
            v_start_date := p_start_date;
        END IF;
        OPEN sys_var FOR 
            WITH user_totals AS
            (SELECT user_id, COUNT(*) cnt, user_name
            FROM message_text JOIN user_information 
            USING(user_id)
            WHERE p_user_id = user_id
            AND ((p_end_date IS NOT NULL AND time_sent BETWEEN v_start_date AND p_end_date)
              OR (p_end_date IS NULL AND time_sent > v_start_date))
            GROUP BY user_name, user_id)
            SELECT user_name, user_id, cnt FROM user_totals WHERE cnt = (SELECT MAX(cnt) FROM user_totals);
    RETURN sys_var;
    END get_user_message_count;

END STATISTICS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."STATISTICS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Package Body TESTING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."TESTING" AS

  FUNCTION GetLatestResults
    RETURN SYS_REFCURSOR AS
    c_Data SYS_REFCURSOR;
  BEGIN
    OPEN c_Data FOR
      SELECT *
        FROM test_results
       WHERE test_timestamp = (SELECT MAX(test_timestamp) FROM test_results);
    RETURN c_Data;
  END GetLatestResults;

  PROCEDURE LogTest (
    p_Method VARCHAR2,
    p_Result VARCHAR2,
    p_Time   TIMESTAMP
  )
  AS
  BEGIN
    INSERT INTO test_results (
      test_id,
      method_name,
      result,
      test_timestamp
    )
    VALUES (
      test_result_seq.NEXTVAL,
      p_Method,
      p_Result,
      p_Time
    );
    
    COMMIT;
  END;

  PROCEDURE CleanTestData AS
  BEGIN
    DELETE FROM user_information
     WHERE user_name = definitions.k_TestUsername;
     
     COMMIT;
  END;

  PROCEDURE RunTests AS
    v_TestTime TIMESTAMP := SYSTIMESTAMP;
  BEGIN
    LogTest('TestAddUser', TestAddUser, v_TestTime);
    LogTest('TestLoginUser', TestLoginUser, v_TestTime);
    
    LogTest('TestChangePassword', TestChangePassword, v_TestTime);
    LogTest('TestCreatePassHash', TestCreatePassHash, v_TestTime);
    LogTest('TestCreateTokenHash', TestCreateTokenHash, v_TestTime);
    
    LogTest('TestLogoutUser', TestLogoutUser, v_TestTime);
    CleanTestData;
    COMMIT;
  END;

  FUNCTION TestAddUser
  RETURN VARCHAR2 AS
    v_Result definitions.t_TestResult;
  BEGIN
    security.add_user(p_username => definitions.k_TestUsername,
                      p_password => definitions.k_TestPassword,
                      p_email    => definitions.k_TestEmail);
    SELECT definitions.k_Pass
      INTO v_Result
      FROM user_information
     WHERE user_name = definitions.k_TestUsername
       AND user_password = security.create_pass_hash(definitions.k_TestUsername, definitions.k_TestPassword)
       AND user_email = definitions.k_TestEmail;
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception '|| SQLCODE ||' occurred: ' || SQLERRM;
      RETURN v_Result;
  END TestAddUser;

  FUNCTION TestChangePassword
    RETURN VARCHAR2 AS
    v_Result definitions.t_TestResult;
  BEGIN
    security.change_password(p_username => definitions.k_TestUsername,
                             p_old_password => definitions.k_TestPassword,
                             p_new_password => definitions.k_TestPassword2);
    
    SELECT definitions.k_Pass
      INTO v_Result
      FROM user_information
     WHERE user_name = definitions.k_TestUsername
       AND user_password = security.create_pass_hash(p_identifier => definitions.k_TestUsername, p_password => definitions.k_TestPassword2);
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception occurred: ' || SQLERRM;
      RETURN v_Result;  
  END TestChangePassword;

  FUNCTION TestLoginUser
    RETURN VARCHAR2 AS
    v_LoggedIn VARCHAR2(1);
    v_Token definitions.t_AuthToken;
    v_Result definitions.t_TestResult;
  BEGIN
    COMMIT;
    
    security.login_user(p_username => definitions.k_TestUsername,
                        p_password => definitions.k_TestPassword);
    
    SELECT islogin, currenttoken
      INTO v_LoggedIn, v_Token
      FROM user_information
     WHERE user_name = definitions.k_TestUsername;
    
    IF v_LoggedIn = 'Y' THEN
      IF v_Token IS NOT NULL THEN
        v_Result := definitions.k_Pass;
      ELSE
        v_Result := 'Failed - login was not successful because of currenttoken. [islogin:'||v_LoggedIn||'] [currenttoken:'||v_Token||']';
      END IF;
    ELSE
      v_Result := 'Failed - login was not successful because of islogin. [islogin:'||v_LoggedIn||'] [currenttoken:'||v_Token||']';
    END IF;
    
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception occurred: ' || SQLERRM;
      RETURN v_Result;  
  END TestLoginUser;

  FUNCTION TestLogoutUser
    RETURN VARCHAR2 AS
    v_LoggedIn VARCHAR2(1);
    v_Token definitions.t_AuthToken;
    v_Result definitions.t_TestResult;
  BEGIN
    security.logout_user(p_username => definitions.k_TestUsername);
    
    SELECT islogin, currenttoken
      INTO v_LoggedIn, v_Token
      FROM user_information
     WHERE user_name = definitions.k_TestUsername;
    
    IF v_LoggedIn = 'N' THEN
      IF v_Token IS NULL THEN
        v_Result := definitions.k_Pass;
      ELSE
        v_Result := 'Failed - logout was not successful because of currenttoken. [islogin:'||v_LoggedIn||'] [currenttoken:'||v_Token||']';
      END IF;
    ELSE
      v_Result := 'Failed - logout was not successful because of islogin. [islogin:'||v_LoggedIn||'] [currenttoken:'||v_Token||']';
    END IF;
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception occurred: ' || SQLERRM;
      RETURN v_Result;
  END TestLogoutUser;

  FUNCTION TestCreatePassHash
    RETURN VARCHAR2 AS
    v_Result definitions.t_TestResult;
    v_Hash   definitions.t_Password;
  BEGIN
    v_Hash := security.create_pass_hash(p_identifier => definitions.k_TestUsername,
                                        p_password   => definitions.k_TestPassword);
    
    IF v_Hash IS NOT NULL THEN
      v_Result := definitions.k_Pass;
    ELSE
      v_Result := 'Password hashing function failed.';
    END IF;
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception occurred: ' || SQLERRM;
      RETURN v_Result;
  END;
  
  FUNCTION TestCreateTokenHash
    RETURN VARCHAR2 AS
    v_Result definitions.t_TestResult;
    v_Hash   definitions.t_AuthToken;
  BEGIN
    v_Hash := security.create_token_hash(p_username => definitions.k_TestUsername,
                                         p_lastlog  => SYSTIMESTAMP);
    
    IF v_Hash IS NOT NULL THEN
      v_Result := definitions.k_Pass;
    ELSE
      v_Result := 'AuthToken hashing function failed.';
    END IF;
    
    RETURN v_Result;
  EXCEPTION
    WHEN OTHERS THEN
      v_Result := 'Exception occurred: ' || SQLERRM;
      RETURN v_Result;
  END;

  FUNCTION TestSendMessage
    RETURN VARCHAR2 AS
  BEGIN
    
    RETURN NULL;
  END TestSendMessage;

  FUNCTION TestSearchUser
    RETURN VARCHAR2 AS
  BEGIN
    -- TODO: Implementation required for FUNCTION TESTING.TestSearchUser
    RETURN NULL;
  END TestSearchUser;

  FUNCTION TestCreateGroup
    RETURN VARCHAR2 AS
  BEGIN
    -- TODO: Implementation required for FUNCTION TESTING.TestCreateGroup
    RETURN NULL;
  END TestCreateGroup;

  FUNCTION TestSendFile
    RETURN VARCHAR2 AS
  BEGIN
    -- TODO: Implementation required for FUNCTION TESTING.TestSendFile
    RETURN NULL;
  END TestSendFile;

  FUNCTION TestDeleteGroup
    RETURN VARCHAR2 AS
  BEGIN
    -- TODO: Implementation required for FUNCTION TESTING.TestDeleteGroup
    RETURN NULL;
  END TestDeleteGroup;

  FUNCTION TestKickUser
    RETURN VARCHAR2 AS
  BEGIN
    -- TODO: Implementation required for FUNCTION TESTING.TestKickUser
    RETURN NULL;
  END TestKickUser;

END TESTING;

/
--------------------------------------------------------
--  DDL for Package Body USER_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CS414_TEAM2"."USER_SETTINGS" AS

  FUNCTION GetUserIcon (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2 AS
    v_Data VARCHAR2(1000);
    v_UserIconId definitions.t_IconId;
  BEGIN
  
    SELECT user_icon_id
      INTO v_UserIconId
      FROM user_information
     WHERE user_id = p_UserId;
  
    SELECT IMAGE_URL
      INTO v_Data
      FROM user_icons
     WHERE icon_id = v_UserIconId;
         
    RETURN v_Data;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN '';
  END GetUserIcon;

  PROCEDURE AssignRandomProfileIcons
  AS
  BEGIN
    UPDATE user_information
       SET user_icon_id = CAST (dbms_random.value(low => 0, high => (SELECT COUNT(*) FROM USER_ICONS WHERE ICON_ID >= 0) - 1) AS INTEGER)
     WHERE user_role != 'admin';
     
     COMMIT;
  END;

  FUNCTION GetAllUserIcons
  RETURN SYS_REFCURSOR AS
    c_Data SYS_REFCURSOR;
  BEGIN
    
    OPEN c_Data FOR
        SELECT icon_id, image_url
          FROM user_icons
         WHERE icon_id >= 0;
    
    RETURN c_Data;
  END GetAllUserIcons;

  PROCEDURE ChangeUserIcon (
    p_UserId definitions.t_UserId,
    p_IconId definitions.t_IconId
  ) AS
  BEGIN
    security.AssertUserIdExists(p_UserId);
    
    UPDATE user_information
       SET user_icon_id = p_IconId
     WHERE user_id = p_UserId;
     
     COMMIT;
    
  END ChangeUserIcon;

  FUNCTION GetUserSystemRole (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2 AS
    v_SystemRole definitions.t_UserRole;
  BEGIN
    SELECT user_role
      INTO v_SystemRole
      FROM user_information
     WHERE user_id = p_UserId;
    
    RETURN v_SystemRole;
  END GetUserSystemRole;

  FUNCTION UserIsBanned (
    p_UserId definitions.t_UserId
  ) RETURN VARCHAR2 AS
    v_IsBanned VARCHAR2(1);
  BEGIN
    security.assertUserIdExists(p_UserId);
    
    SELECT banned
      INTO v_IsBanned
      FROM user_information
     WHERE user_id = p_UserId;
    
    RETURN v_IsBanned;
  END UserIsBanned;

END USER_SETTINGS;

/

  GRANT EXECUTE ON "CS414_TEAM2"."USER_SETTINGS" TO "CS414_TEAM2_WEB";
--------------------------------------------------------
--  DDL for Synonymn DBMS_CRYPTO
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "DBMS_CRYPTO" FOR "SYS"."DBMS_CRYPTO";
--------------------------------------------------------
--  DDL for Synonymn DBMS_LOB
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "DBMS_LOB" FOR "SYS"."DBMS_LOB";
--------------------------------------------------------
--  DDL for Synonymn DBMS_RANDOM
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "DBMS_RANDOM" FOR "SYS"."DBMS_RANDOM";
--------------------------------------------------------
--  DDL for Synonymn DUAL
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "DUAL" FOR "SYS"."DUAL";
--------------------------------------------------------
--  DDL for Synonymn UTL_I18N
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "UTL_I18N" FOR "SYS"."UTL_I18N";
--------------------------------------------------------
--  DDL for Synonymn UTL_RAW
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE PUBLIC SYNONYM "UTL_RAW" FOR "SYS"."UTL_RAW";
--------------------------------------------------------
--  Constraints for Table FILE_EXTENSIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."FILE_EXTENSIONS" MODIFY ("EXTENSION" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."FILE_EXTENSIONS" ADD CONSTRAINT "FILE_EXTENSIONS_PK" PRIMARY KEY ("EXTENSION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FLAG_RELATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."FLAG_RELATIONS" MODIFY ("USER_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."FLAG_RELATIONS" MODIFY ("TEXT_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."FLAG_RELATIONS" ADD CONSTRAINT "FLAG_RELATIONS_PK" PRIMARY KEY ("USER_ID", "TEXT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INVITATION_TABLE
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" MODIFY ("INVITE_STATUS" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" ADD CONSTRAINT "PK_INVITE_ID" PRIMARY KEY ("USER_ID", "GROUP_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" MODIFY ("IS_ACTIVITY_NEW" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" MODIFY ("LOCAL_ROLE" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" MODIFY ("IS_INVITED" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table MESSAGE_FILE
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" MODIFY ("ENCRYPTED_FILE" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" ADD PRIMARY KEY ("FILE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" MODIFY ("TEXT_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" MODIFY ("EXTENSION" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table MESSAGE_GROUP
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."MESSAGE_GROUP" ADD PRIMARY KEY ("GROUP_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."MESSAGE_GROUP" MODIFY ("CRYPTO_KEY" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_GROUP" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_GROUP" MODIFY ("VISIBLE" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_GROUP" MODIFY ("PRIVATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table MESSAGE_TEXT
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("VISIBLE" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" ADD CONSTRAINT "PK_TEXT_ID" PRIMARY KEY ("TEXT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("USER_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("GROUP_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("ENCRYPTED_TEXT" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("PERMISSION_ROLE" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" MODIFY ("TIME_SENT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table NOTIFICATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" MODIFY ("NOTIF_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" MODIFY ("USER_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" MODIFY ("NOTIF_BODY" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" MODIFY ("TIME_SENT" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" ADD CONSTRAINT "NOTIFICATIONS_PK" PRIMARY KEY ("NOTIF_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TEST_RESULTS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."TEST_RESULTS" MODIFY ("TEST_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."TEST_RESULTS" MODIFY ("METHOD_NAME" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."TEST_RESULTS" MODIFY ("RESULT" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."TEST_RESULTS" MODIFY ("TEST_TIMESTAMP" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."TEST_RESULTS" ADD CONSTRAINT "TEST_RESULTS_PK" PRIMARY KEY ("TEST_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table USER_ICONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."USER_ICONS" MODIFY ("ICON_ID" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_ICONS" MODIFY ("IMAGE_URL" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_ICONS" ADD CONSTRAINT "USER_ICONS_PK" PRIMARY KEY ("ICON_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table USER_INFORMATION
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" MODIFY ("USER_NAME" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" MODIFY ("USER_EMAIL" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" MODIFY ("USER_PASSWORD" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" ADD PRIMARY KEY ("USER_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" ADD UNIQUE ("USER_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" ADD UNIQUE ("USER_EMAIL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" MODIFY ("USER_ROLE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table USER_RELATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" MODIFY ("USER_ID_A" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" MODIFY ("USER_ID_B" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" MODIFY ("RELATION" NOT NULL ENABLE);
  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" ADD CONSTRAINT "USER_RELATIONS_PK" PRIMARY KEY ("USER_ID_A", "USER_ID_B")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" ADD CONSTRAINT "USER_RELATIONS_CHK1" CHECK (relation in ('F','B')) ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FLAG_RELATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."FLAG_RELATIONS" ADD CONSTRAINT "FLAG_RELATIONS_FK1_USERID" FOREIGN KEY ("USER_ID")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "CS414_TEAM2"."FLAG_RELATIONS" ADD CONSTRAINT "FLAG_RELATIONS_FK1_TEXTID" FOREIGN KEY ("TEXT_ID")
	  REFERENCES "CS414_TEAM2"."MESSAGE_TEXT" ("TEXT_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table INVITATION_TABLE
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" ADD CONSTRAINT "INVITATION_TABLE_FK1_USERID" FOREIGN KEY ("GROUP_ID")
	  REFERENCES "CS414_TEAM2"."MESSAGE_GROUP" ("GROUP_ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "CS414_TEAM2"."INVITATION_TABLE" ADD CONSTRAINT "INVITATION_TABLE_FK1_GROUPID" FOREIGN KEY ("USER_ID")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table MESSAGE_FILE
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."MESSAGE_FILE" ADD CONSTRAINT "FK_MESSAGE_FILE_TEXT_ID" FOREIGN KEY ("TEXT_ID")
	  REFERENCES "CS414_TEAM2"."MESSAGE_TEXT" ("TEXT_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table MESSAGE_TEXT
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" ADD CONSTRAINT "FK_FILE_ID_MESSAGE_TEXT" FOREIGN KEY ("FILE_ID")
	  REFERENCES "CS414_TEAM2"."MESSAGE_FILE" ("FILE_ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" ADD CONSTRAINT "FK_USER" FOREIGN KEY ("USER_ID")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "CS414_TEAM2"."MESSAGE_TEXT" ADD CONSTRAINT "MESSAGE_TEXT_FK1" FOREIGN KEY ("GROUP_ID")
	  REFERENCES "CS414_TEAM2"."MESSAGE_GROUP" ("GROUP_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table NOTIFICATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."NOTIFICATIONS" ADD CONSTRAINT "NOTIFICATIONS_FK1_USERID" FOREIGN KEY ("USER_ID")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table USER_INFORMATION
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."USER_INFORMATION" ADD CONSTRAINT "USER_INFORMATION_ICON_FK1" FOREIGN KEY ("USER_ICON_ID")
	  REFERENCES "CS414_TEAM2"."USER_ICONS" ("ICON_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table USER_RELATIONS
--------------------------------------------------------

  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" ADD CONSTRAINT "USER_RELATIONS_FK1_USERA" FOREIGN KEY ("USER_ID_A")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "CS414_TEAM2"."USER_RELATIONS" ADD CONSTRAINT "USER_RELATIONS_FK2_USERB" FOREIGN KEY ("USER_ID_B")
	  REFERENCES "CS414_TEAM2"."USER_INFORMATION" ("USER_ID") ON DELETE CASCADE ENABLE;
